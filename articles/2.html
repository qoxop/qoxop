<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="keywords" content=",,,,,,,,,">
    <title>qoxop | 首页(2)</title>
    <link rel="stylesheet" href="/assets/common.css">
    <link rel="stylesheet" href="/assets/articleList.css">
    <link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  
    <script async src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.1/highlight.min.js"></script>
    
</head>
<body>
    <div id="app">
        <header>
          <div class="content_box header_inner">
            <div class="logo">
              <div class="logoImg">
                <img src="/assets/icon.png" alt="">
              </div>
              <div class="logoText">
                jiw
              </div>
            </div>
            <nav class="navigator">
              <ul>
                
                <li class="actived">
                    <a href="#">
                        HOME
                    </a>
                </li>
                
                <li class="">
                    <a href="/category.html">
                        CATEGORY
                    </a>
                </li>
                
                <li class="">
                    <a href="/tags.html">
                        标签
                    </a>
                </li>
                
                <li class="">
                    <a href="/link.html">
                        链接
                    </a>
                </li>
                
                <li class="">
                    <a href="/about.html">
                        关于我
                    </a>
                </li>
                
              </ul>
            </nav>
          </div>
        </header>
        <div id="main">
           <div class="content_box">
    <div id="left_content">
        <!-- 这里存放主要内容 -->
       <div class="article_list">
    
    <section class="article_item">
        <h3><a href="/anything/简历.html">简历</a></h3>
        <div class="preview md_html">
            <p>注意要点</p>
<ol>
<li>邮件和附件标题署名，姓名-求职岗位</li>
</ol>
<p>拥有两年的web开发经验(包括校内经历)，在校期间在工作室做的PC端的信息管理系统，工作期间主要是做移动端开发，负责编写业务代码。经常使用的框架是react和vue，偏爱使用react。</p>
<h3 id="%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C">工作经验</h3>
<h4 id="%E5%85%AC%E5%8F%B8%E6%98%8E%E6%BA%90%E4%BA%91%E5%AE%A2%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8">公司明源云客电子商务有限公司</h4>
<ul>
<li>
<p>xxxx-xx-xx</p>
<p>​	我参与了公司雅居宝app主要是一个ToC的售楼应用，我主要负责楼盘详情、经纪人消息模块 、经纪人消息模块 等以及后期的bug修复和样式优化。遇较大的难题就是业务数据的管理，主要在一个刷新的问题</p>
</li>
<li>
<p>xxxx-xx-xx   移动销售app</p>
<p>减少样式组件的封装，抽象交互组件</p>
<p>无限滚动列表的尝试，</p>
</li>
<li>
<p>自动部署机制</p>
</li>
</ul>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/anything/简历.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/anything/述职.html">述职</a></h3>
        <div class="preview md_html">
            <h3 id="2018%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93">2018年工作总结</h3>
<p>2018年主要负责的是</p>
<h4 id="%E9%94%80%E5%94%AE%E7%BB%8F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9D%97%E5%92%8C%E5%AE%A2%E6%88%B7%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91%E5%92%8C%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96">销售经理 数据统计模块和客户模块的业务需求开发和功能优化</h4>
<p>销售经理首页的样式和交互优化、统一缺省页和搜索文字文案、客户分配列表的自定义筛选和自定义分组功能、销售经理排班功能等等...</p>
<h4 id="%E8%90%A5%E9%94%80%E6%80%BB%E5%92%8C%E6%81%92%E5%A4%A7%E8%90%A5%E9%94%80%E6%80%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E9%9C%80%E6%B1%82">营销总和恒大营销总的一些数据统计需求</h4>
<p>营销总查看转化率和各种预期情况统计，营销总查看房源模块，营销总穿透到项目明细等...</p>
<h4 id="%E5%85%B6%E4%BB%96%E7%9A%84%E5%8C%85%E6%8B%AC%E4%BA%91%E5%AE%A2%E5%90%8E%E5%8F%B0%E5%92%8C%E8%81%8C%E4%B8%9A%E9%A1%BE%E9%97%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E7%9A%84%E9%9C%80%E6%B1%82">其他的包括云客后台和职业顾问相关的一些零散的需求</h4>
<p>置业顾问鸡汤、后台的批量免逾期、后台客户全选逻辑统一</p>
<h4 id="%E7%84%B6%E5%90%8E%E5%B0%B1%E6%98%AF%E4%B8%80%E4%BA%9Bbug%E7%9A%84%E4%BF%AE%E5%A4%8D">然后就是一些bug的修复</h4>
<h3 id="2018%E5%B9%B4%E7%9A%84%E4%B8%8D%E8%B6%B3%E7%82%B9">2018年的不足点</h3>
<ul>
<li>记录和总结较少</li>
<li>需求时间评估不足，导致求快的心理从而影响了代码质量</li>
<li>对于工作和学习的规划不够</li>
</ul>
<h3 id="2019%E5%B9%B4%E7%9A%84%E8%A7%84%E5%88%92">2019年的规划</h3>
<p>对自己的要求</p>
<ol>
<li>提高代码质量，工作效率</li>
</ol>
<p>学习的计划</p>
<ol>
<li>巩固前端的基础知识</li>
<li>学习nodejs</li>
</ol>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/anything/述职.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/CSS动画.html">CSS动画</a></h3>
        <div class="preview md_html">
            <h3 id="transition">transition</h3>
<ul>
<li>transition-delay           设置延迟过渡的时间</li>
<li>transition-duration    设置过渡所需的时间</li>
<li>transition-property    设置需要过渡的属性</li>
<li>transition-timing-function    定义速度模式</li>
</ul>
<h5 id="%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B">速度模型</h5>
<ul>
<li>ease       逐渐放慢</li>
<li>linear     匀速</li>
<li>ease-in   加速</li>
<li>ease-out 减速</li>
<li>cubic-bezier函数       http://cubic-bezier.com/</li>
</ul>
<h5 id="%E5%B1%80%E9%99%90">局限</h5>
<ol>
<li>transition需要事件触发，所以没法在网页加载时自动发生。</li>
<li>transition是一次性的，不能重复发生，除非一再触发。</li>
<li>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</li>
<li>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</li>
</ol>
<h3 id="animation">animation</h3>
<ul>
<li>animation-name: 动画名称</li>
<li>animation-duration: 持续时间</li>
<li>animation-timing-function: 速度模型</li>
<li>animation-delay: 延迟执行</li>
<li>animation-direction: 循环播放时，动画播放的方向（normal、reverse、alernate、alternate-reverse）</li>
<li>animation-iteration-count: 定义动画在结束前运行的次数（infinite表示无限次）</li>
<li>animation-fill-mode: 结束动画时的状态（none、backwards:第一帧，forwards:最后一帧，both）</li>
<li>animation-play-state: 动画播放状态（paused暂停，running运行）</li>
</ul>
<h4 id="%40keyframes">@keyframes</h4>
<p>keyframes关键字用来定义动画的各个状态，它的写法相当自由。</p>
<pre><code class="hljs language-css">@<span class="hljs-keyword">keyframes</span> rainbow {
  0% { <span class="hljs-attribute">background</span>: <span class="hljs-number">#c00</span> }
  50% { <span class="hljs-attribute">background</span>: orange }
  100% { <span class="hljs-attribute">background</span>: yellowgreen }
}
@<span class="hljs-keyword">keyframes</span> rainbow {
  <span class="hljs-selector-tag">from</span> { <span class="hljs-attribute">background</span>: <span class="hljs-number">#c00</span> }
  50% { <span class="hljs-attribute">background</span>: orange }
  <span class="hljs-selector-tag">to</span> { <span class="hljs-attribute">background</span>: yellowgreen }
}
</code></pre>
<h4 id="animation-timing-function">animation-timing-function</h4>
<blockquote>
<p>/* Keyword values */
animation-timing-function: ease;
animation-timing-function: ease-in;
animation-timing-function: ease-out;
animation-timing-function: ease-in-out;
animation-timing-function: linear;
animation-timing-function: step-start;
animation-timing-function: step-end;</p>
<p>/* Function values */
animation-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1);
animation-timing-function: steps(4, end);
animation-timing-function: frames(10);</p>
<p>/* Multiple animations */
animation-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1.0, 0.1);</p>
</blockquote>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/CSS动画.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/css布局.html">css布局</a></h3>
        <div class="preview md_html">
            <h3 id="css%E7%9B%92%E6%A8%A1%E5%9E%8B">CSS盒模型</h3>
<blockquote>
<p>CSS盒模型（译者注：也被称为“盒模型”）是网页布局的基础 ——每个元素被表示为一个矩形的方框，框的内容、内边距、边界和外边距像洋葱的膜那样，一层包着一层构建起来。浏览器渲染网页布局时，它会算出每个框的内容要用什么样式，周围的洋葱层有多大，以及框相对于其它框放在哪里。</p>
</blockquote>
<h4 id="%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%BB%84%E6%88%90">盒模型组成</h4>
<p>由外到里分别为: content, padding, border, margin</p>
<h4 id="%E4%B8%A4%E7%A7%8D%E6%A0%87%E5%87%86">两种标准</h4>
<p>标准模型(content-box)、IE模型(border-box)，通过box-sizing切换，具体的区别在于width、height属性描述限制的范围不同</p>
<h4 id="%E8%8E%B7%E5%8F%96%E7%9B%92%E5%AD%90%E7%9A%84%E5%AE%BD%E9%AB%98">获取盒子的宽高</h4>
<ol>
<li>
<p>取内联样式设置的宽高（取得的是css是width/height属性）</p>
<pre><code class="hljs language-javascript">dom.style.width/height
</code></pre>
</li>
<li>
<p>取渲染后的宽高，仅ie（取得的是标准模型的宽高）</p>
<pre><code class="hljs language-javascript">dom.currentStyle.width/height
</code></pre>
</li>
<li>
<p>取渲染后的宽高, 通用兼容性好（取得的是标准模型的宽高）</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">window</span>.getComputedStyle(dom).width/height
<span class="hljs-comment">// 如果dom元素是一个滚动盒子，那么结果需要是减去滚动调后的值</span>
</code></pre>
</li>
<li>
<p>通过计算盒子在视窗的绝对位置 （取得的是IE模型的宽高）</p>
<pre><code class="hljs language-javascript">dom.getBoundingClientRect().width/height
</code></pre>
</li>
<li>
<p><code>offsetWidth</code> / <code>offsetWidth</code> （取得的是IE模型的宽高）</p>
<pre><code class="hljs language-javascript">dom.offsetWidth/offsetWidth
</code></pre>
</li>
</ol>
<h4 id="%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%A1%8C%E9%99%B7">外边距塌陷</h4>
<blockquote>
<p>块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并。注意浮动元素和绝对定位元素的外边距不会折叠。</p>
</blockquote>
<h5 id="%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%A1%8C%E9%99%B7%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5">外边距塌陷的三种基本情况</h5>
<ul>
<li>相邻元素之间</li>
<li>父元素与其第一个或最后一个子元素之间</li>
<li>空的块级元素</li>
</ul>
<h5 id="%E9%98%B2%E6%AD%A2%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%A1%8C%E9%99%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">防止外边距塌陷的解决方案</h5>
<h6 id="bfc-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87">BFC 块级格式化上下文</h6>
<blockquote>
<p>BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。</p>
</blockquote>
<ul>
<li>原理：
<ol>
<li>BFC元素的子元素在垂直方向的边距会发生重叠（为什么时垂直方向，应为块级元素独占一行，其他元素确实脱离了正常的文档流）</li>
<li>BFC元素的边距不会与它的子浮动元素的box重叠，也就是说浮动元素的margin也同样会撑开父元素的高度或高度(如果没有限制宽高的话)，同时与子浮动元素相邻的子元素之间也不会发生重叠</li>
<li>BFC在页面是一个独立的容器，外面的元素不会影响它里面的元素</li>
<li>计算BFC元素高度时浮动元素也会参与计算，也就是说即使BFC元素内的尾部有自动清楚所有浮动的功能，即使BFC元素的子元素都是浮动的，BFC元素的高度也不会为<strong>零</strong></li>
</ol>
</li>
<li>如何创建
<ol>
<li>css属性float不为none</li>
<li>css属性position不为默认值</li>
<li>css属性display属性与table相关的属性</li>
<li>css属性overflow属性不为visible</li>
</ol>
</li>
</ul>
<h3 id="css%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88">CSS布局方案</h3>
<h4 id="flex%E5%B8%83%E5%B1%80">Flex布局</h4>
<blockquote>
<p>Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。 任何一个容器(包括行内元素)都可以指定为 Flex 布局。</p>
<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
</blockquote>
<h5 id="1.-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1. 基本概念</h5>
<p>采用Flex布局的元素称为Flex容器, 其子元素就自动变成了Flex项目</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.flexbox</span> {
    <span class="hljs-attribute">display</span>: flex;
}
</code></pre>
<p>Flex容器有两根轴—主轴和交叉轴，Flex项目就是依据这两个轴来进行布局的(包括调整大小与对齐方式)，默认的主轴是水平轴(-&gt;),交叉轴是垂直轴(up to down)，轴起止与border。</p>
<h5 id="2.-%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7">2. 容器属性</h5>
<ol>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ol>
<p>分别设置主轴方向，换行方式，主轴方向和换行方式，项目在主轴方式的分布规则，项目在交叉轴方向上的对齐方式，</p>
<h6 id="2.1-flex-direction-%E5%B1%9E%E6%80%A7">2.1 flex-direction 属性</h6>
<p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse; <span class="hljs-comment">/* →  ←  ↓  ↑  */</span>
}
</code></pre>
<h6 id="2.2-flex-wrap%E5%B1%9E%E6%80%A7">2.2 flex-wrap属性</h6>
<p>默认情况下Flex项目都排在了与主轴平行的轴线上，flex-wrap属性定义如果一条轴线排不下时如何换行。</p>
<ul>
<li><code>nowrap</code>(默认)：不换行，超出部分怎么显示有父元素决定</li>
<li><code>wrap</code>：正常换行</li>
<li><code>wrap-reverse</code>: 反向换行</li>
</ul>
<h6 id="2.3-flex-flow">2.3 flex-flow</h6>
<p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p>
<h6 id="2.4-justify-content%E5%B1%9E%E6%80%A7">2.4 justify-content属性</h6>
<p>很多人喜欢将其定义为 &quot; 项目在主轴上的对齐方式 &quot;, 但个人喜欢理解为项目在主轴方式的分布规则，因为这个属性对于项目元素刚好排满一行主轴轴线时，并不会起任何作用，只有在排不满时，主轴轴线上出现了多余的空间， justify-content属性就是来描述如何分配这些空间的。</p>
<ul>
<li><code>flex-start</code>: 所有项目往主轴的起始位置靠，剩余的空间都在主轴的终止方向上</li>
<li><code>flex-end</code>: 与<code>flex-start</code>相反</li>
<li><code>center</code>: 所有项目往主轴的中间位置位置靠，剩余空间放两边</li>
<li><code>space-between</code>:  两端元素贴壁(两端对齐)，剩余空间均匀分配给项目间的空隙</li>
<li><code>space-around</code>: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h6 id="2.5-align-items%E5%B1%9E%E6%80%A7">2.5 align-items属性</h6>
<p><code>align-items</code>属性定义项目在交叉轴上如何对齐。align的英文意思为：使对其，成一直线， items是指项目，那么<code>align-items</code>就是可以理解为项目是对其于怎样的一条线的。</p>
<p>首先我们知道项目是在主轴方向上进行堆叠分布的，但如果项目在交叉轴方向上的长度不一致，就会参差不齐，这就需要对其，是将项目都往交叉轴的起始位置靠还是往终止位置靠，还是往交叉轴的中间对齐，还是将每个项目在交叉轴上的长度都拉升到一致，又或者将所有项目的第一行文字放同一个主轴轴轴线上再按这个限制去摆放项目</p>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<p>之前关于轴、对齐的误解：对齐指子元素如何再父元素中排布，比如说元素A向左对齐那么A就会尽可能地往父元素的左边靠，这一点是很好理解，误解的是这么一个描述 &quot;<code>align-items</code>属性定义项目在交叉轴上如何对齐&quot; ,个人的感觉是项目是如何贴在交叉轴轴线上的(因为比如向左对齐就是元素贴在了父元素的左边框上了，但起始向左对齐的重点是在&quot;<strong>左</strong>&quot;字上面), 所以如果把描述改为 &quot;<code>align-items</code>属性定义项目是往的交叉轴哪个方向对齐&quot; 会更好理解一点</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/css布局.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/CSS布局方案.html">CSS布局方案</a></h3>
        <div class="preview md_html">
            <h3 id="%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80">浮动布局</h3>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.float_box</span> {
    <span class="hljs-attribute">float</span>: left; <span class="hljs-comment">/*or right*/</span>
}
</code></pre>
<p>在其<strong>原有位置</strong>处脱离布局流(处于上层位置)，同时失去默认宽度(100%父级元素)，向左或右浮动，浮动的元素不会与非浮动的正常兄弟原属发生重叠，且浮动元素不会撑高父元素的高度，可通过设置父元素让浮动元素超出时隐藏</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/CSS布局方案.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/Es6异步.html">Es6异步</a></h3>
        <div class="preview md_html">
            <h3 id="generator">Generator</h3>
<h4 id="%E5%9F%BA%E7%A1%80%E5%86%99%E6%B3%95">基础写法</h4>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gn</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"begin"</span>);
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'world'</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">'ending'</span>;
}
<span class="hljs-keyword">var</span> g = gn()	<span class="hljs-comment">//这里gn函数内的语句不会立即执行，而是返回一个遍历器对象Iterator </span>
g.next();	<span class="hljs-comment">//log-&gt;begin return-&gt;{value:'hello', done: false}</span>
g.next();	<span class="hljs-comment">//return-&gt;{value:'world', done: false}</span>
g.next();	<span class="hljs-comment">//return-&gt;{value:'ending', done: true}</span>
g.next();	<span class="hljs-comment">//return-&gt;{value:undefined, done: true}</span>
</code></pre>
<p>generator本身就是发生器的意思，就是generator函数可以生产一系列的状态。他的作用是可以让函数分步执行，同时还保留了<strong>作用域</strong>。</p>
<p>yield表达式其实是一个暂停标志，它的参数作为该状态下的返回值(next方法的返回值)。yield表达式默认不会产生值（或者说产生一个undefined），当yield表达式嵌入在另一个表达式中时，必须用括号包裹起来，同时被嵌入的表达式是被视作下一个状态的程序（包括yield本身也是），所以next方法可以传递一个参数，该参数会被当作yield表达是产出值。</p>
<h4 id="for...of">for...of</h4>
<p>for...of 循环可以自动遍历 Generator 函数时生成的Iterator对象，且不再需要调用next方法。当返回的对象中done属性为true时停止循环，所以return返回的值不会出现在for...of中</p>
<h4 id="generator.prototype.throw()">Generator.prototype.throw()</h4>
<p>抛出一个错误，然后可以在函数内部捕获，如果内部没有捕获代码（或者说数量不足），错误将由外部处理。可以接受一个参数，该参数会被catch语句接收。</p>
<h4 id="generator.prototype.return()">Generator.prototype.return()</h4>
<p>提前终止遍历器对象的状态，并返回给定的值（参数），如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;
}
<span class="hljs-keyword">var</span> g = numbers();
g.next() <span class="hljs-comment">// { value: 1, done: false }</span>
g.next() <span class="hljs-comment">// { value: 2, done: false }</span>
g.return(<span class="hljs-number">5</span>) <span class="hljs-comment">// { value: 3, done: false }</span>
g.next() <span class="hljs-comment">// { value: 5, done: true }</span>
</code></pre>
<h4 id="yield*-%E8%A1%A8%E8%BE%BE">yield* 表达</h4>
<p>相当于代码复制，</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'x'</span>;
  <span class="hljs-keyword">yield</span>* foo();
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'y'</span>;
}
<span class="hljs-comment">// 等同于</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'x'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'y'</span>;
}
</code></pre>
<h4 id="generator-%E5%87%BD%E6%95%B0%E7%9A%84this">Generator 函数的this</h4>
<p>Generator 函数总是返回一个遍历器而不是this，也不可以用new来调用。</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.b = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.c = <span class="hljs-number">3</span>;
}
<span class="hljs-keyword">var</span> f = F.call(F.prototype);

f.next();  <span class="hljs-comment">// Object {value: 2, done: false}</span>
f.next();  <span class="hljs-comment">// Object {value: 3, done: false}</span>
f.next();  <span class="hljs-comment">// Object {value: undefined, done: true}</span>

f.a <span class="hljs-comment">// 1</span>
f.b <span class="hljs-comment">// 2</span>
f.c <span class="hljs-comment">// 3</span>
</code></pre>
<h4 id="%E5%BA%94%E7%94%A8">应用</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//状态机</span>
<span class="hljs-keyword">var</span> clock = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Tick!'</span>);
    <span class="hljs-keyword">yield</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Tock!'</span>);
    <span class="hljs-keyword">yield</span>;
  }
};
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//异步操作的同步化表示</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">yield</span> request(<span class="hljs-string">"http://some.url"</span>);
  <span class="hljs-keyword">var</span> resp = <span class="hljs-built_in">JSON</span>.parse(result);
    <span class="hljs-built_in">console</span>.log(resp.value);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url</span>) </span>{
  makeAjaxCall(url, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>{
    it.next(response);
  });
}
<span class="hljs-keyword">var</span> it = main();
it.next();
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">iterEntries</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(obj);	<span class="hljs-comment">//获取对象的所有key（字符串数组）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt; keys.length; i++) {
    <span class="hljs-keyword">let</span> key = keys[i];
    <span class="hljs-keyword">yield</span> [key, obj[key]];
  }
}
<span class="hljs-keyword">let</span> myObj = { <span class="hljs-attr">foo</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">7</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> iterEntries(myObj)) {
  <span class="hljs-built_in">console</span>.log(key, value);
}
</code></pre>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/Es6异步.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/eslint.html">eslint</a></h3>
        <div class="preview md_html">
            <h1 id="eslint">ESlint</h1>
<h3 id="%E5%AE%9A%E4%B9%89">定义</h3>
<p>ESLint 是一个开源的 JavaScript 代码检查工具</p>
<h3 id="%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8">安装使用</h3>
<pre><code class="hljs language-javascript">npm i -g eslint
</code></pre>
<ul>
<li>
<p>命令行使用</p>
<pre><code class="hljs">eslint [options] [<span class="hljs-keyword">file</span>|<span class="hljs-keyword">dir</span>|<span class="hljs-keyword">glob</span>]*

</code></pre>
</li>
<li>
<p>与编辑器一起配置使用，安装eslint插件</p>
</li>
</ul>
<h3 id="%E9%85%8D%E7%BD%AE">配置</h3>
<h5 id="%E6%B3%A8%E9%87%8A%E9%85%8D%E7%BD%AE">注释配置</h5>
<h5 id="%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE">文件配置</h5>
<p>在.eslintrc.*（json,js,yaml）文件 或者在package.json文件中的eslintConfig字段配置</p>
<ul>
<li>
<p>代码和解析</p>
<pre><code class="hljs language-json"><span class="hljs-string">"eslintConfig"</span>: {
    //配置解析器
    <span class="hljs-attr">"parser"</span>: <span class="hljs-string">"babel-eslint"</span>,
        
    //配置解析的选项
    <span class="hljs-attr">"parserOptions"</span>: {
        <span class="hljs-attr">"ecmaVersion"</span>: <span class="hljs-number">6</span>,	//ecmaScript的版本
        <span class="hljs-attr">"sourceType"</span>: <span class="hljs-string">"module"</span>,	//源码类型，<span class="hljs-attr">"script"</span>(默认)或者<span class="hljs-attr">"module"</span>，
        <span class="hljs-attr">"ecmaFeatures"</span>: {	//额外的语言特性
            <span class="hljs-attr">"globalReturn"</span>: <span class="hljs-literal">true</span>,	// 允许在全局作用域下使用 return 语句
            <span class="hljs-attr">"jsx"</span>: <span class="hljs-literal">true</span>,	//启用jsx
            <span class="hljs-attr">"impliedStrict"</span>: <span class="hljs-literal">true</span>	//启用全局 strict mode (如果 ecmaVersion 是 <span class="hljs-number">5</span> 或更高)
        },
    },
    
    //继承配置，可以是一个字符串或字符串数组，字符串内容可以是一个文件或者一个已安装的npm包
    <span class="hljs-attr">"extends"</span>: <span class="hljs-string">"airbnb-base"</span>,
    
    //配置启用环境
    <span class="hljs-attr">"env"</span>: {
        <span class="hljs-attr">"browser"</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">"node"</span>: <span class="hljs-literal">true</span>
        //还以其他的等等。。。
    },
    
    //全局变量名配置
    <span class="hljs-attr">"globals"</span>: {
        <span class="hljs-attr">"var1"</span>: <span class="hljs-literal">true</span>,	//在某个文件中访问var1不会报错了
    	<span class="hljs-attr">"var2"</span>: <span class="hljs-literal">true</span>	//在某个文件中访问var2会报错，即使全局环境中存在var2这个变量
    },
	
	//使用第三方插件
    //全局安装的 ESLint 只能使用全局安装的插件。
    //本地安装的 ESLint 不仅可以使用本地安装的插件还可以使用全局安装的插件。
    <span class="hljs-attr">"plugins"</span>: [
        <span class="hljs-string">"html"</span>
    ],
    
    //配置规则，http://eslint.cn/docs/rules/
    //<span class="hljs-string">"off"</span> 或 <span class="hljs-number">0</span> - 关闭规则
    //<span class="hljs-string">"warn"</span> 或 <span class="hljs-number">1</span> - 开启规则，使用警告级别的错误：warn (不会导致程序退出)
    //<span class="hljs-string">"error"</span> 或 <span class="hljs-number">2</span> - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)
    <span class="hljs-string">"rules"</span>: {
        <span class="hljs-attr">"indent"</span>: [
            <span class="hljs-string">"error"</span>,	//第一个为级别
            <span class="hljs-number">4</span>			//其他的为该规则的参数
        ],
        <span class="hljs-attr">"semi"</span>: <span class="hljs-number">0</span>,		//级别
        <span class="hljs-attr">"comma-dangle"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">"linebreak-style"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">"no-console"</span>: <span class="hljs-number">0</span>
    }
}
</code></pre>
</li>
<li>
<p>优先级</p>
<p>文件内注释 &gt; 配置文件，当前目录的配置文件  &gt;  父级目录的配置文件</p>
</li>
<li>
<p>忽视解析的文件或目录，用 .eslintignore 文件进行配置</p>
</li>
</ul>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/eslint.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/Markdown.html">Markdown</a></h3>
        <div class="preview md_html">
            
        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/Markdown.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/mobx.html">mobx</a></h3>
        <div class="preview md_html">
            <h4 id="autorun">Autorun</h4>
<p>参数：一个使用了observable数据的函数</p>
<p>返回：disposer函数，调用该函数可以去取消autorun，以及取消对computed值的计算</p>
<p>错误处理：可以用disposer.onError方法来覆盖Reaction的默认日志行为。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> age = observable(<span class="hljs-number">10</span>)
<span class="hljs-keyword">const</span> dispose = autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (age.get() &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Age should not be negative"</span>)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Age"</span>, age.get())
})
age.set(<span class="hljs-number">18</span>)  <span class="hljs-comment">// 输出: Age 18</span>
age.set(<span class="hljs-number">-10</span>) <span class="hljs-comment">// 输出: Age should not be negative</span>
age.set(<span class="hljs-number">5</span>)   <span class="hljs-comment">// 已恢复; 输出: Age 5</span>

dispose.onError(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">"Please enter a valid age"</span>)
})

age.set(<span class="hljs-number">-5</span>)  <span class="hljs-comment">// 显示alert弹出框</span>
</code></pre>
<p>全局的onError方法：全局的 onError 处理方法可以通过 extras.onReactionError(handler)来设置。</p>
<h4 id="%40observer">@observer</h4>
<p>将React组件转变成响应式组件。它用mobx.autorun 包装了组件的render函数以确保任何组件渲染中使用的数据变化是都可以强制刷新组件。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">"mobx-react"</span>;

<span class="hljs-keyword">var</span> timerData = observable({
    <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>
});

setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    timerData.secondsPassed++;
}, <span class="hljs-number">1000</span>);

@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: { this.props.timerData.secondsPassed } <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span> )
    }
};
<span class="hljs-comment">//secondsPassed改变会触发组件刷新</span>
React.render(&lt;Timer timerData={timerData} /&gt;, document.body);
/*secondsPassed改变不会触发组件刷新，因为此处只是单纯地传递了字面值而已，Timer无法获取到timerData.secondsPassed的变化*/
React.render(&lt;Timer timerData={timerData.secondsPassed} /&gt;, document.body); 
</code></pre>
<p>@observer、autorun函数所能观察的目标只能是引用，为了触发 **autorun **值需要通过引用来传递而不是字面值来传递。</p>
<ol>
<li>
<p>无状态函数组件</p>
<pre><code class="hljs language-react">import {observer} from &quot;mobx-react&quot;;

const Timer = observer(({ timerData }) =&gt;
    &lt;span&gt;Seconds passed: { timerData.secondsPassed } &lt;/span&gt;
);
</code></pre>
</li>
<li>
<p>可观察的局部组件状态</p>
<pre><code class="hljs language-react">import {observer} from &quot;mobx-react&quot;
import {observable} from &quot;mobx&quot;

@observer class Timer extends React.Component {
    @observable secondsPassed = 0

    componentWillMount() {
        setInterval(() =&gt; {
            this.secondsPassed++
        }, 1000)
    }

    render() {
        return (&lt;span&gt;Seconds passed: { this.secondsPassed } &lt;/span&gt; )
    }
})

React.render(&lt;Timer /&gt;, document.body)
</code></pre>
<p>mobx局部组件状态的变化只会触发render、componentWillUpdate、componentDidUpdate</p>
</li>
<li>
<p>componentWillReact 生命周期钩子</p>
<p>当使用 mobx-react 时可以定义一个新的生命周期钩子函数 componentWillReact(一语双关)。当组件因为它观察的数据发生了改变，它会安排重新渲染，这个时候 componentWillReact 会被触发。</p>
<h4 id="action">action</h4>
<p>应该永远只对<strong>修改</strong>状态的函数使用动作</p>
<ul>
<li>
<p>绑定的动作</p>
<pre><code class="hljs language-react">class Ticker {
    @observable tick = 0

    @action.bound
    increment() {
        this.tick++ // 'this' 永远都是正确的
    }
}
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="mobx%E4%BC%9A%E5%AF%B9%E4%BB%80%E4%B9%88%E5%81%9A%E5%87%BA%E5%8F%8D%E5%BA%94%EF%BC%9F">Mobx会对什么做出反应？</h4>
<blockquote>
<p>Mobx 会对在<strong>追踪函数</strong>执行过程中<strong>读取</strong>现存的可观察属性做出反应。</p>
</blockquote>
<p>调用过至少一次getter(注册观察者)，使用setter(执行过程)</p>
<p>Mobx的observable函数就是通过普通对象生产一个拥有getter、setter属性的对象，其中getter的首次调用用于初始化初值并注册该属性的观察者，</p>
<p>单例模式、观察者模式、</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/mobx.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/pk.html">pk</a></h3>
        <div class="preview md_html">
            <p>在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在</p>
<p>当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/pk.html">Read</a>
            </div>
        </div>
    </section>
    
    <div class="page_box">
    <div class="page_pre">
        <a class="page_pre_item" class="" href="/articles/1.html">FIRST</a>
        <a class="page_pre_item" href="/articles/1.html">
            <i class="iconfont icon-previous"></i>
        </a>
    </div>
    <div class="page_num">
        
            <a href="/articles/1.html" class="page_num_item ">
                1
            </a>
        
            <a href="/articles/2.html" class="page_num_item actived">
                2
            </a>
        
            <a href="/articles/3.html" class="page_num_item ">
                3
            </a>
        
            <a href="/articles/4.html" class="page_num_item ">
                4
            </a>
        
    </div>
    <div class="page_next">
        <a class="page_next_item" href="/articles/3.html">
            <i class="iconfont icon-next"></i>
        </a>
        <a class="page_next_item" href="/articles/4.html">LAST</a>
    </div>
    </div>
</div>
    </div>
    <aside>
        <div class="profile_banner"></div>
        <div class="profile_logo">
        <img src="/assets/logo.png" alt="">
        </div>
        <div class="profile_name">
            qoxop
        </div>
        <div class="profile_motto">
            一只单身的帅狗, 打代码、打游戏、撸猫、无恶不做~
        </div>
        <div class="profile_info">
        <div>
            <div class="iconbox"><em class="iconfont icon-github"></em></div>
            <div class="icontext">github</div>
        </div>
        <div>
            <div class="iconbox"><em class="iconfont icon-resume"></em></div>
            <div class="icontext">resume</div>
        </div>
        <div>...</div>
        </div>
    </aside>
</div>
        </div>
        <footer></footer>
      </div>
</body>
</html>