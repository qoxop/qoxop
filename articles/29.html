<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="keywords" content=",,,,,,,,,">
    <title>qoxop | 首页(29)</title>
    <link rel="stylesheet" href="/assets/common.css">
    <link rel="stylesheet" href="/assets/articleList.css">
    <link href="/assets/monokai_sublime.min.css" rel="stylesheet">  
    <script async src="/assets/highlight.min.js"></script>
     
      <script src="/assets/hot_reload.js"></script>
    
</head>
<body>
    <article id="app">
        <header>
          <h1>张集伟的个人博客</h1>
          <div class="content_box header_inner">
            <div class="logo">
              <div class="logoImg">
                <img src="/assets/icon.png" alt="">
              </div>
              <div class="logoText">
                jiw
              </div>
            </div>
            <nav class="navigator">
              <ul>
                
                <li class="actived">
                    <a href="#">
                        HOME
                    </a>
                </li>
                
                <li class="">
                    <a href="/category.html">
                        CATEGORY
                    </a>
                </li>
                
                <li class="">
                    <a href="/tags.html">
                        标签
                    </a>
                </li>
                
                <li class="">
                    <a href="/link.html">
                        链接
                    </a>
                </li>
                
                <li class="">
                    <a href="/about.html">
                        关于我
                    </a>
                </li>
                
              </ul>
            </nav>
          </div>
        </header>
        <main id="main">
           <div class="content_box">
    <div id="left_content">
        <!-- 这里存放主要内容 -->
       <div class="article_list">
    
    <section class="article_item">
        <h3><a href="/前端开发/对js原型链的理解.html">对js原型链的理解</a></h3>
        <div class="preview md_html">
            <h3 id="%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E6%9C%AC%E8%B4%A8">原型链的本质</h3>
<p>a对象的<code>__proto__</code> 属性指向b对象，而b对象的<code>__proto__</code> 指向c对象，这就是一条原型链</p>
<h3 id="%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E4%BD%9C%E7%94%A8">原型链的作用</h3>
<p>如果访问对象自身某个不存在属性时，程序就会去对象的<code>__proto__</code>属性指向的对象去查找，如果再找不到就会继续按照这样的规则去继续查找，知道找到为止或者最后的对像的<code>__proto__</code>属性指向null</p>
<p>由于属性的查找的优先级是先查自身自有属性再去原型链中查找，这就造成了所谓的属性屏蔽</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 演示原型链</span>
<span class="hljs-keyword">let</span> a = {<span class="hljs-attr">pa</span>: <span class="hljs-string">'a'</span>};
<span class="hljs-keyword">let</span> b = {<span class="hljs-attr">pb</span>: <span class="hljs-string">'b'</span>};
<span class="hljs-keyword">let</span> c = {<span class="hljs-attr">pc</span>: <span class="hljs-string">'c'</span>};
a.__proto__ = b;
b.__proto__ = c;
a.pb === b.pb <span class="hljs-comment">// true</span>
a.pc === c.pc <span class="hljs-comment">// true</span>
c = {<span class="hljs-attr">pc</span>: <span class="hljs-string">'cc'</span>};
a.pc === c.pc <span class="hljs-comment">// false, c的指向改变了</span>
</code></pre>
<h3 id="%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F">创建对象的方式</h3>
<ol>
<li>字面量 / <code>new Object(obj)</code> ：构造函数都是Object</li>
<li>构造函数 :  构造函数为自定义的构造函数</li>
<li><code>Object.create(srcObj: any)</code> ：构造函数与<code>srcObj</code>的构造函数一致，作用是新建一个对象使得该对象的<code>__proto__</code>属性指向<code>srcObj</code></li>
</ol>
<h3 id="javascript%E4%B8%AD%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%BD%A2%E6%88%90">JavaScript中原型链的形成</h3>
<p>对象的原型指向它的构造函数<strong>在调用时</strong>的<code>prototype</code>属性(的引用)，如果需要如果需要动态修改对象的原型，只能去修改<code>prototype</code>属性的属性，而不能直接给<code>prototype</code>属性赋值(因为引用改变了)</p>
<p><code>js</code>中只有<strong>函数</strong>与<strong>类</strong>(本质上也是函数)有默认的<code>prototype</code>属性，而且<code>prototype</code>属性对象的<code>constructor</code>属性指向函数本身或者类的构造函数</p>
<p>一些概念：原型对象指的就是prototype，原型链就是<code>__proto__</code>链</p>
<p>注意点：原型对象上的方法和属性是所有实例对象共有的方法和属性</p>
<h3 id="%E6%93%8D%E4%BD%9C%E7%AC%A6">操作符</h3>
<h4 id="instanceof">instanceof</h4>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span> </span>{<span class="hljs-comment">/* anything here */</span>};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span> </span>{
    A.call(<span class="hljs-keyword">this</span>)
    <span class="hljs-comment">/* anything here */</span>
}；
B.prototype = <span class="hljs-built_in">Object</span>.create(A.prototype)
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> B
b installceof B; <span class="hljs-comment">// 作用(原理)上等于b.__proto__ === B.prototype || b.__proto__ === A.prototype</span>
<span class="hljs-comment">// 如果需要判断直接父类</span>
b.__proto__.constructor === B.prototype.constructor
</code></pre>
<h4 id="new">new</h4>
<ol>
<li>一个新的对象被创建，它继承自构造函数的prototype，<code>f = {__proto__: F.prototype}</code></li>
<li>构造函数被执行，相应的传参被传入，同时上下文(this)会被指定为这个新的实例。<code>(this = f)</code></li>
<li>如果构造函数返回了一个对象，那实例就会变成这个对象，new操作符的作用相当于没有，如果没有返回任何东西，那new操作符将会把上下文(this)做为函数的返回， <code>return this</code></li>
</ol>
<h3 id="%E5%90%84%E7%A7%8D%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B%E7%9A%84prototype">各种默认类型的prototype</h3>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}
F.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// true</span>
</code></pre>
<h3 id="%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95">实现继承的几种方法</h3>
<ol>
<li>只继承自有属性(利用构造函数)</li>
</ol>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.type = <span class="hljs-string">"parent"</span>
}
Parent.prototype.sayHi = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hi"</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>{
  Parent.call(<span class="hljs-keyword">this</span>)
  <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"child"</span>
}
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child
child.tpye === <span class="hljs-string">"parent"</span> <span class="hljs-comment">// true</span>
child.name === <span class="hljs-string">"child"</span> <span class="hljs-comment">// true</span>
child.sayHi() <span class="hljs-comment">// Error</span>
</code></pre>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/对js原型链的理解.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/后端开发/login.html">login</a></h3>
        <div class="preview md_html">
            <ol>
<li>checkLogin： 向后台询问登陆态，不传userId 和 password，如果是登陆态，后台回直接放回登陆信息</li>
</ol>
<pre><code class="hljs language-flow">st=&gt;start: /login
e=&gt;end: End
st-&gt;e
</code></pre>
<pre><code class="hljs language-flow">st=&gt;start: Start|past:&gt;http://www.google.com[blank]
e=&gt;end: End:&gt;http://www.google.com
op1=&gt;operation: My Operation|past
op2=&gt;operation: Stuff|current
sub1=&gt;subroutine: My Subroutine|invalid
cond=&gt;condition: Yes 
or No?|approved:&gt;http://www.baidu.com
c2=&gt;condition: Good idea|rejected
io=&gt;inputoutput: catch something...|request

st-&gt;op1(right)-&gt;cond
cond(yes, right)-&gt;c2
cond(no)-&gt;sub1(left)-&gt;op1
c2(yes)-&gt;io-&gt;e
c2(no)-&gt;op2-&gt;e
​```


</code></pre>
<pre><code class="hljs language-flow">st=&gt;start: start
end=&gt;end: end

st-&gt;end
</code></pre>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/后端开发/login.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/后端开发/备注.html">备注</a></h3>
        <div class="preview md_html">
            
        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/后端开发/备注.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/经验总结/周记.html">周记</a></h3>
        <div class="preview md_html">
            <h2 id="%E5%91%A8%E8%AE%B0">周记</h2>
<p>2017年12月18日～2017年12月24日										张集伟</p>
<p>​	这一周，在工作上主要是修复了恒大营销总应用的两个问题，一个是数据展示问题一个是网络请求问题，第一个问题主要是对需求的理解不清造成，第二个问题主要是由于粗心造成。</p>
<p>​	而其他的时间主要在学习用webpack搭建前端项目和学习一个新的前端状态管理库Mobx，对于webpack的学习主要是了解它的各个配置项的作用以及了解根据具体需求来配个相应的loader与插件。而mobx与redux一样都是能与react很好配合的一个状态管理器，但是两者的实现方式却是大不相同。</p>
<p>​	用redux的话，状态更新只能由action触发，以纯函数的方式定义reducer函数来规定state的更新规则，所以每次局部状态的更新免不了要进行一次state的拷贝，而且redux采用单个的store来管理应用的状态，所以在项目越来越复杂时store也会变得过于庞大而不便于管理，所以需要拆分reducer来优化，而且redux原生并不支持异步的action，需要通过中间件来实现异步action，当然，对于redux，是有它适合的应用场景和优势，在这方面上以后还是要继续去了解的。</p>
<p>​	对于mobx，我自己的理解是，mobx通过将普通对象转化成一个可观察对象（原理是基于js对象的getter与setter属性），在设置可观察对象时，会自动触发某些行为，在这方面上它与redux是类似的。但mobx提供更加细粒化的观察，首先可观察对象是一个单例模式，mobx观察的是引用，当引用内的值发现改变就能触发行为，可以不通过派发action和用reducer更新状态，提供了更加自由的方式来管理应用状态，能更及时地相应状态变化。mobx可以采用多store来管理状态，方便业务拆分，不过这应该也有不好的地方，因为有可能造成状态的混乱或者其他的问题。当然对于这两个状态管理库，目前还没有很深入地理解，还需要在往后的时间继续学习。</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/经验总结/周记.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/读书笔记/git.html">git</a></h3>
        <div class="preview md_html">
            <h3 id="fetch">fetch</h3>
<h4 id="%E6%8F%8F%E8%BF%B0">描述</h4>
<p>拉去远程分支，默认再本地增加origin/XXX分支</p>
<h4 id="%E5%8F%82%E6%95%B0">参数</h4>
<p>--prune / -p ：fetch之前删除本地中对远程分支的引用，如果改引用再远程分支中已经不存在</p>
<h3 id="commit">commit</h3>
<p>git commit --amend 修补提交</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/读书笔记/git.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/读书笔记/ssh.html">ssh</a></h3>
        <div class="preview md_html">
            <h4 id="%E7%BB%91%E5%AE%9A%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3">绑定本地端口</h4>
<pre><code class="hljs language-bash">ssh -D 8080 user@host
</code></pre>
<p>ssh建立一个socket，监听本地的8080端口，就自动把它转移到SSH连接上面，发往远程主机。</p>
<h4 id="%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">本地端口转发</h4>
<pre><code class="hljs language-bash">ssh -L localPort: remoteHost :remotePort SSHHost
</code></pre>
<p>ssh链接由**执行方(本地)<strong>向</strong>SSHHost(远程)**发起，ssh监听本地端口localPort，将localPort数据转发给了SSHHost的sshServer，sshServer将数据转发给远程服务端口remoteHost:remotePort,远程服务器返回的数据将原路返回到本地端口。</p>
<h4 id="%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">远程端口转发</h4>
<pre><code class="hljs language-bash">ssh -R localPort: remoteHost :remotePort SSHHost
</code></pre>
<p>ssh链接由**执行方(远程)<strong>向</strong>SSHHost(本地)<strong>发起，<strong>执行方ssh</strong>要求</strong>SSHHost(本地)**上的sshServer监听localPort端口并将localPort端口数据返回给自己，由自己将数据转发给远程服务端口remoteHost:remotePort，远程服务器返回的数据将原路返回到本地端口。</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/读书笔记/ssh.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/读书笔记/vsCode使用.html">vsCode使用</a></h3>
        <div class="preview md_html">
            <hr />
<h2 id="style%3A-ocean">style: ocean</h2>
<h3 id="%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91">代码编辑</h3>
<h5 id="%E6%A0%BC%E5%BC%8F%E8%B0%83%E6%95%B4">格式调整</h5>
<ul>
<li>代码缩进：ctrl + [ , ctrl +  ]</li>
<li>代码折叠：ctrl + shift +[ , ctrl + shift + ]</li>
<li>格式化：ctrl + alt + f （自定义快捷键）</li>
<li>上下行交换：alt + up 或 alt + down</li>
<li>向下(上)复制一行：shift + alt + up 或 shift + alt + down</li>
<li>向下插入一行：ctrl + enter</li>
<li>向上插入一行：ctrl + shift + enter</li>
<li>代码美化：ctrl + alt + b （自定义，美化插件beautify，可自定义配置）</li>
<li>复制或裁剪一行：不选中，ctrl+c , ctrl + x</li>
</ul>
<h5 id="%E5%85%89%E6%A0%87">光标</h5>
<ul>
<li>移动到行首或行末：home , end</li>
<li>移动到文件结尾或开头：ctrl + end， ctrl + home</li>
<li>向下选择行：ctrl + i</li>
<li>选择光标到行末位置：shift + end</li>
<li>选择光标到行首位置： shift + home</li>
<li>光标跳到上次的位置：ctrl + u</li>
<li>多光标：ctrl + alt + up/down</li>
<li>同时选中所有匹配的：Ctrl+Shift+L （再也不同ctrl + F/H 了）</li>
<li>以光标处为起点向上下左右选择文本：ctrl + shift + 上/下/左/右</li>
</ul>
<h5 id="%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84">代码重构</h5>
<ul>
<li>跳转到定义处：选中 -&gt; F12</li>
<li>定义处缩略图：只看一眼而不跳转过去Alt+F12</li>
<li>列出所有的引用：Shift+F12 (强)</li>
<li>修改变量名：选中变量名 -&gt; F12 -&gt; 修改 （强）</li>
</ul>
<h5 id="%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2">查找替换</h5>
<ul>
<li>查找：ctrl + f</li>
<li>查找替换：ctrl + h</li>
<li>整个文件夹查找：ctrl + shift + f</li>
</ul>
<h5 id="%E6%98%BE%E7%A4%BA%E7%9B%B8%E5%85%B3">显示相关</h5>
<ul>
<li>全屏：F11</li>
<li>zoomIn/zoomOut：Ctrl + =/Ctrl + -</li>
<li>侧边栏显/隐：Ctrl+B</li>
<li>预览markdown Ctrl+Shift+V</li>
</ul>
<h3 id="%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8E%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86">编辑器与窗口管理</h3>
<ul>
<li>打开/关闭一个新的窗口：ctrl + shift + n/w</li>
<li>新建一个文件：ctrl + n</li>
<li>关闭当前打开的一个文件：ctrl + w</li>
<li>在打开的文件中切换：ctrl + tab</li>
<li>新建编辑器视口并切换：ctrl + 1/2/3</li>
</ul>
<h3 id="%E6%8F%92%E4%BB%B6">插件</h3>
<h5 id="%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91-2">代码编辑</h5>
<ul>
<li>自动修改闭合标签：Auto Rename Tag</li>
<li>代码美化：Beautify</li>
<li>代码检验：ESLint</li>
<li>npm包导入提醒：node.js Modules Intellisense</li>
<li>路径智能提示：Path Intellisense</li>
</ul>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/读书笔记/vsCode使用.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/读书笔记/webstorm.html">webstorm</a></h3>
        <div class="preview md_html">
            <h2 id="%E5%BF%AB%E6%8D%B7%E9%94%AE">快捷键</h2>
<ol>
<li>ctrl + shift + n: 打开工程中的文件，目的是打开当前工程下任意目录的文件。</li>
<li>ctrl + j: 输出模板</li>
<li>ctrl + b: 跳到变量申明处</li>
<li>ctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap withAbbreviation)</li>
<li>ctrl + []: 匹配 {}[]</li>
<li>ctrl + F12: 可以显示当前文件的结构</li>
<li>ctrl + x: 剪切(删除)行，不选中，直接剪切整个行，如果选中部分内容则剪切选中的内容</li>
<li>alt + left/right:标签切换</li>
<li>ctrl + r: 替换</li>
<li>ctrl + shift + up: 行移动</li>
<li>shift + alt + up: 块移动(if(){},while(){}语句块的移动)</li>
<li>ctrl + d: 行复制</li>
<li>ctrl + shift + ]/[: 选中块代码</li>
<li>ctrl + / : 单行注释</li>
<li>ctrl + shift + / : 块注释</li>
<li>ctrl + shift + i : 显示当前CSS选择器或者JS函数的详细信息</li>
<li>ctrl + '-/+': 可以折叠项目中的任何代码块，它不是选中折叠，而是自动识别折叠。</li>
<li>ctrl + '.': 折叠选中的代码的代码。</li>
<li>shift + esc: 当前激活的任意小窗口最小化，也可以是alt+数字键，数字在小窗口有显示。</li>
<li>alt + '7': 显示当前的函数结构。</li>
<li>如果是*.html页面，则在文件名下的导航栏某DOM结构上右键，可以全选当前DOM结构。</li>
</ol>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/读书笔记/webstorm.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/Es6异步.html">Es6异步</a></h3>
        <div class="preview md_html">
            <h3 id="generator">Generator</h3>
<h4 id="%E5%9F%BA%E7%A1%80%E5%86%99%E6%B3%95">基础写法</h4>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gn</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"begin"</span>);
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'world'</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">'ending'</span>;
}
<span class="hljs-keyword">var</span> g = gn()	<span class="hljs-comment">//这里gn函数内的语句不会立即执行，而是返回一个遍历器对象Iterator </span>
g.next();	<span class="hljs-comment">//log-&gt;begin return-&gt;{value:'hello', done: false}</span>
g.next();	<span class="hljs-comment">//return-&gt;{value:'world', done: false}</span>
g.next();	<span class="hljs-comment">//return-&gt;{value:'ending', done: true}</span>
g.next();	<span class="hljs-comment">//return-&gt;{value:undefined, done: true}</span>
</code></pre>
<p>generator本身就是发生器的意思，就是generator函数可以生产一系列的状态。他的作用是可以让函数分步执行，同时还保留了<strong>作用域</strong>。</p>
<p>yield表达式其实是一个暂停标志，它的参数作为该状态下的返回值(next方法的返回值)。yield表达式默认不会产生值（或者说产生一个undefined），当yield表达式嵌入在另一个表达式中时，必须用括号包裹起来，同时被嵌入的表达式是被视作下一个状态的程序（包括yield本身也是），所以next方法可以传递一个参数，该参数会被当作yield表达是产出值。</p>
<h4 id="for...of">for...of</h4>
<p>for...of 循环可以自动遍历 Generator 函数时生成的Iterator对象，且不再需要调用next方法。当返回的对象中done属性为true时停止循环，所以return返回的值不会出现在for...of中</p>
<h4 id="generator.prototype.throw()">Generator.prototype.throw()</h4>
<p>抛出一个错误，然后可以在函数内部捕获，如果内部没有捕获代码（或者说数量不足），错误将由外部处理。可以接受一个参数，该参数会被catch语句接收。</p>
<h4 id="generator.prototype.return()">Generator.prototype.return()</h4>
<p>提前终止遍历器对象的状态，并返回给定的值（参数），如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;
}
<span class="hljs-keyword">var</span> g = numbers();
g.next() <span class="hljs-comment">// { value: 1, done: false }</span>
g.next() <span class="hljs-comment">// { value: 2, done: false }</span>
g.return(<span class="hljs-number">5</span>) <span class="hljs-comment">// { value: 3, done: false }</span>
g.next() <span class="hljs-comment">// { value: 5, done: true }</span>
</code></pre>
<h4 id="yield*-%E8%A1%A8%E8%BE%BE">yield* 表达</h4>
<p>相当于代码复制，</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'x'</span>;
  <span class="hljs-keyword">yield</span>* foo();
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'y'</span>;
}
<span class="hljs-comment">// 等同于</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'x'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'y'</span>;
}
</code></pre>
<h4 id="generator-%E5%87%BD%E6%95%B0%E7%9A%84this">Generator 函数的this</h4>
<p>Generator 函数总是返回一个遍历器而不是this，也不可以用new来调用。</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.b = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.c = <span class="hljs-number">3</span>;
}
<span class="hljs-keyword">var</span> f = F.call(F.prototype);

f.next();  <span class="hljs-comment">// Object {value: 2, done: false}</span>
f.next();  <span class="hljs-comment">// Object {value: 3, done: false}</span>
f.next();  <span class="hljs-comment">// Object {value: undefined, done: true}</span>

f.a <span class="hljs-comment">// 1</span>
f.b <span class="hljs-comment">// 2</span>
f.c <span class="hljs-comment">// 3</span>
</code></pre>
<h4 id="%E5%BA%94%E7%94%A8">应用</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//状态机</span>
<span class="hljs-keyword">var</span> clock = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Tick!'</span>);
    <span class="hljs-keyword">yield</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Tock!'</span>);
    <span class="hljs-keyword">yield</span>;
  }
};
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//异步操作的同步化表示</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">yield</span> request(<span class="hljs-string">"http://some.url"</span>);
  <span class="hljs-keyword">var</span> resp = <span class="hljs-built_in">JSON</span>.parse(result);
    <span class="hljs-built_in">console</span>.log(resp.value);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url</span>) </span>{
  makeAjaxCall(url, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>{
    it.next(response);
  });
}
<span class="hljs-keyword">var</span> it = main();
it.next();
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">iterEntries</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(obj);	<span class="hljs-comment">//获取对象的所有key（字符串数组）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt; keys.length; i++) {
    <span class="hljs-keyword">let</span> key = keys[i];
    <span class="hljs-keyword">yield</span> [key, obj[key]];
  }
}
<span class="hljs-keyword">let</span> myObj = { <span class="hljs-attr">foo</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">7</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> iterEntries(myObj)) {
  <span class="hljs-built_in">console</span>.log(key, value);
}
</code></pre>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/Es6异步.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/经验总结/周记.html">周记</a></h3>
        <div class="preview md_html">
            <h2 id="%E5%91%A8%E8%AE%B0">周记</h2>
<p>2017年12月18日～2017年12月24日										张集伟</p>
<p>​	这一周，在工作上主要是修复了恒大营销总应用的两个问题，一个是数据展示问题一个是网络请求问题，第一个问题主要是对需求的理解不清造成，第二个问题主要是由于粗心造成。</p>
<p>​	而其他的时间主要在学习用webpack搭建前端项目和学习一个新的前端状态管理库Mobx，对于webpack的学习主要是了解它的各个配置项的作用以及了解根据具体需求来配个相应的loader与插件。而mobx与redux一样都是能与react很好配合的一个状态管理器，但是两者的实现方式却是大不相同。</p>
<p>​	用redux的话，状态更新只能由action触发，以纯函数的方式定义reducer函数来规定state的更新规则，所以每次局部状态的更新免不了要进行一次state的拷贝，而且redux采用单个的store来管理应用的状态，所以在项目越来越复杂时store也会变得过于庞大而不便于管理，所以需要拆分reducer来优化，而且redux原生并不支持异步的action，需要通过中间件来实现异步action，当然，对于redux，是有它适合的应用场景和优势，在这方面上以后还是要继续去了解的。</p>
<p>​	对于mobx，我自己的理解是，mobx通过将普通对象转化成一个可观察对象（原理是基于js对象的getter与setter属性），在设置可观察对象时，会自动触发某些行为，在这方面上它与redux是类似的。但mobx提供更加细粒化的观察，首先可观察对象是一个单例模式，mobx观察的是引用，当引用内的值发现改变就能触发行为，可以不通过派发action和用reducer更新状态，提供了更加自由的方式来管理应用状态，能更及时地相应状态变化。mobx可以采用多store来管理状态，方便业务拆分，不过这应该也有不好的地方，因为有可能造成状态的混乱或者其他的问题。当然对于这两个状态管理库，目前还没有很深入地理解，还需要在往后的时间继续学习。</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/经验总结/周记.html">Read</a>
            </div>
        </div>
    </section>
    
    <div class="page_box">
    <div class="page_pre">
        <a class="page_pre_item" class="" href="/articles/1.html">FIRST</a>
        <a class="page_pre_item" href="/articles/28.html">
            <i class="iconfont icon-previous"></i>
        </a>
    </div>
    <div class="page_num">
        
    </div>
    <div class="page_next">
        <a class="page_next_item" href="/articles/30.html">
            <i class="iconfont icon-next"></i>
        </a>
        <a class="page_next_item" href="/articles/57.html">LAST</a>
    </div>
    </div>
</div>
    </div>
    <aside>
        <div class="profile_banner"></div>
        <div class="profile_logo">
        <img src="/assets/logo.png" alt="">
        </div>
        <div class="profile_name">
            qoxop
        </div>
        <div class="profile_motto">
            一只单身的帅狗, 打代码、打游戏、撸猫、无恶不做~~~
        </div>
        <div class="profile_info">
        <div>
            <div class="iconbox"><em class="iconfont icon-github"></em></div>
            <div class="icontext">github</div>
        </div>
        <div>
            <div class="iconbox"><em class="iconfont icon-resume"></em></div>
            <div class="icontext">resume</div>
        </div>
        <div>...</div>
        </div>
    </aside>
</div>
        </main>
        <footer id="footer"></footer>
      </article>
      <div class="shortcut-tools">
          <div onclick="exec('scrollToTop')" class="goto-top-btn">Top</div>
          <div onclick="exec('scrollToBottom')" class="goto-bottom-btn">Bottom</div>
          <div onclick="exec('goback')" class="goback-btn">goback</div>
      </div>
      <script src="/assets/common.js"></script>
</body>
</html>