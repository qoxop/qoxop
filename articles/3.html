<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="keywords" content=",,,,,,,,,">
    <title>qoxop | 首页(3)</title>
    <link rel="stylesheet" href="/assets/common.css">
    <link rel="stylesheet" href="/assets/articleList.css">
    <link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  
    <script async src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.1/highlight.min.js"></script>
    
</head>
<body>
    <div id="app">
        <header>
          <div class="content_box header_inner">
            <div class="logo">
              <div class="logoImg">
                <img src="/assets/icon.png" alt="">
              </div>
              <div class="logoText">
                jiw
              </div>
            </div>
            <nav class="navigator">
              <ul>
                
                <li class="actived">
                    <a href="#">
                        HOME
                    </a>
                </li>
                
                <li class="">
                    <a href="/category.html">
                        CATEGORY
                    </a>
                </li>
                
                <li class="">
                    <a href="/tags.html">
                        标签
                    </a>
                </li>
                
                <li class="">
                    <a href="/link.html">
                        链接
                    </a>
                </li>
                
                <li class="">
                    <a href="/about.html">
                        关于我
                    </a>
                </li>
                
              </ul>
            </nav>
          </div>
        </header>
        <div id="main">
           <div class="content_box">
    <div id="left_content">
        <!-- 这里存放主要内容 -->
       <div class="article_list">
    
    <section class="article_item">
        <h3><a href="/config.html">config</a></h3>
        <div class="preview md_html">
            <pre><code class="hljs language-js">proxyTable: {
    <span class="hljs-string">'/api/admin/resource/upload-img'</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">'http://modeling-dev.mypaas.com.cn'</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">pathRewrite</span>: {
            <span class="hljs-string">'^/api'</span>: <span class="hljs-string">'/api'</span>
        }
    },
    <span class="hljs-string">'/api'</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">'http://test-qmyxcg.myscrm.cn/'</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">cookieDomainRewrite</span>: {
            <span class="hljs-string">"*"</span>: <span class="hljs-string">""</span>
        }
    }
},
</code></pre>
<pre><code class="hljs language-js">{
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"workspace"</span>,
    <span class="hljs-string">"version"</span>: <span class="hljs-string">"1.0.0"</span>,
    <span class="hljs-string">"author"</span>: <span class="hljs-string">"paas-cli"</span>,
    <span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>,
    <span class="hljs-string">"description"</span>: <span class="hljs-string">"paas-cli"</span>,
    <span class="hljs-string">"private"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"scripts"</span>: {
        <span class="hljs-string">"sync"</span>: <span class="hljs-string">"paas sync &amp;&amp; yarn"</span>,
        <span class="hljs-string">"git-pull"</span>: <span class="hljs-string">"node bin/git"</span>,
        <span class="hljs-string">"start"</span>: <span class="hljs-string">"paas start --port 8081 --mode Wechat"</span>,
        <span class="hljs-string">"startApp"</span>: <span class="hljs-string">"paas startApp"</span>,
        <span class="hljs-string">"design"</span>: <span class="hljs-string">"paas design"</span>
    },
    <span class="hljs-string">"dependencies"</span>: {
        <span class="hljs-string">"add"</span>: <span class="hljs-string">"^2.0.6"</span>,
        <span class="hljs-string">"broker-common"</span>: <span class="hljs-string">"git+ssh://git@git.mysoft.com.cn:yunke-paas/broker-common.git"</span>,
        <span class="hljs-string">"broker-http"</span>: <span class="hljs-string">"git+ssh://git@git.mysoft.com.cn:yunke-paas/broker-http.git"</span>,
        <span class="hljs-string">"broker-store"</span>: <span class="hljs-string">"git+ssh://git@git.mysoft.com.cn:yunke-paas/broker-store.git"</span>,
        <span class="hljs-string">"qs"</span>: <span class="hljs-string">"^6.5.1"</span>,
        <span class="hljs-string">"v-tooltip"</span>: <span class="hljs-string">"^2.0.0-rc.25"</span>,
        <span class="hljs-string">"vue-upload-component"</span>: <span class="hljs-string">"^2.7.4"</span>,
        <span class="hljs-string">"vue2-better-scroll"</span>: <span class="hljs-string">"^1.0.6"</span>,
        <span class="hljs-string">"webapp"</span>: <span class="hljs-string">"git+ssh://git@git.mysoft.com.cn:mic-paas/webapp.gitt#nightly"</span>
    },
    <span class="hljs-string">"appConfig"</span>: {
        <span class="hljs-string">"pluginIds"</span>: <span class="hljs-string">"broker-store"</span>
    },
    <span class="hljs-string">"devDependencies"</span>: {
        <span class="hljs-string">"eslint"</span>: <span class="hljs-string">"^4.1.0"</span>,
        <span class="hljs-string">"eslint-config-airbnb-base"</span>: <span class="hljs-string">"^12.1.0"</span>,
        <span class="hljs-string">"eslint-config-prettier"</span>: <span class="hljs-string">"^2.4.0"</span>,
        <span class="hljs-string">"eslint-config-xo"</span>: <span class="hljs-string">"^0.18.2"</span>,
        <span class="hljs-string">"eslint-plugin-html"</span>: <span class="hljs-string">"^4.0.1"</span>,
        <span class="hljs-string">"eslint-plugin-import"</span>: <span class="hljs-string">"^2.8.0"</span>,
        <span class="hljs-string">"eslint-plugin-prettier"</span>: <span class="hljs-string">"^2.2.0"</span>,
        <span class="hljs-string">"husky"</span>: <span class="hljs-string">"^0.14.3"</span>,
        <span class="hljs-string">"lint-staged"</span>: <span class="hljs-string">"^4.2.1"</span>,
        <span class="hljs-string">"prettier"</span>: <span class="hljs-string">"^1.7.0"</span>,
        <span class="hljs-string">"rimraf"</span>: <span class="hljs-string">"^2.6.2"</span>,
        <span class="hljs-string">"v-tooltip"</span>: <span class="hljs-string">"^2.0.0-rc.25"</span>
    },
    <span class="hljs-string">"eslintConfig"</span>: {
        <span class="hljs-string">"parser"</span>: <span class="hljs-string">"babel-eslint"</span>,
        <span class="hljs-string">"parserOptions"</span>: {
            <span class="hljs-string">"sourceType"</span>: <span class="hljs-string">"module"</span>
        },
        <span class="hljs-string">"extends"</span>: <span class="hljs-string">"airbnb-base"</span>,
        <span class="hljs-string">"plugins"</span>: [
            <span class="hljs-string">"html"</span>
        ],
        <span class="hljs-string">"rules"</span>: {
            <span class="hljs-string">"indent"</span>: [
                <span class="hljs-string">"error"</span>,
                <span class="hljs-number">4</span>
            ],
            <span class="hljs-string">"semi"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-string">"comma-dangle"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-string">"linebreak-style"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-string">"no-console"</span>: <span class="hljs-number">0</span>
        }
    },
    <span class="hljs-string">"appConfig"</span>: {
        <span class="hljs-string">"pluginIds"</span>:<span class="hljs-string">"broker-common"</span>,
        <span class="hljs-string">"loadLocalModules"</span>:<span class="hljs-literal">true</span>
    }
}

</code></pre>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/config.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/redux.html">redux</a></h3>
        <div class="preview md_html">
            <h3 id="%E6%A6%82%E5%BF%B5">概念</h3>
<ul>
<li>reducer ：一个形式为 (state,action) =&gt; state 的纯函数。
<ul>
<li>定义了状态的更新规则，即每个action如何改变应用的 state</li>
</ul>
</li>
<li>state ：记录应用的状态，可以包含各种业务数据，也可以包含各个组件共享数据</li>
<li>store：可以理解为应用状态的管理者。
<ul>
<li>获取state：getState()方法获取state</li>
<li>更新state：dispatch(action) 方法更新state，也是唯一的改变state的方法</li>
<li>订阅state：subscribe(listener) 注册监听器，每一个次状态的变化都会触发listener函数</li>
<li>注销监听：通过 subscribe(listener) 返回的函数注销监听器。</li>
</ul>
</li>
<li>action：描述一个动作的对象，type属性是必须其他结构任意。</li>
</ul>
<h3 id="%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99">三大原则</h3>
<ul>
<li>单一数据源</li>
<li>state是只读的</li>
<li>使用纯函数来执行修改</li>
</ul>
<h3 id="%E5%8F%91%E8%B5%B7action">发起action</h3>
<ul>
<li>
<p><code>dispatch(action)</code></p>
</li>
<li>
<p><code>dispatch(actionCreate(type))</code></p>
</li>
<li>
<p><code>( payload=&gt; dispatch(actionCreate(payload)) )(payload)</code></p>
<pre><code class="hljs language-javascript">doSomething = <span class="hljs-function"><span class="hljs-params">payload</span> =&gt;</span> dispatch(actionCreate(payload));
doSomething(payload);
</code></pre>
</li>
<li>
<p>action 创建函数除了返回 action 对象外还可以返回函数。这时，这个 action 创建函数就成为了 thunk。</p>
</li>
</ul>
<h3 id="createaction">CreateAction</h3>
<ul>
<li>CreateAction 可以返回一个<code>action</code>对象,也可以返回一个 形式为 <code>dispatch =&gt; {/* doSomething... , dispatch(***) */}</code></li>
</ul>
<h3 id="%E5%BC%82%E6%AD%A5action">异步action</h3>
<p>原理是将原本一个动作分解为多个，比如一个网络请求动作可分为 发起请求，获取中，得到结果(成功或失败)。</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/redux.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/typeScript.html">typeScript</a></h3>
        <div class="preview md_html">
            <h3 id="%E7%B1%BB%E5%9E%8B">类型</h3>
<ol>
<li>
<p>类型声明，冒号+类型  -&gt; :boolean | :number | :string</p>
</li>
<li>
<p>类型种类：布尔值(boolean)、 数字(number) 、字符串(string)、数组(Array|Array<number>)、元组(Tuple)、枚举(enum)、任意类型(Any)、void(函数无返回值、只能赋值为null和undefined)、Null 、Undefined、never</p>
</li>
<li>
<p>元组：一个固定长度、元素类型固定的数组：let x: [string, number]</p>
</li>
<li>
<p>枚举：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Color {Red, Green, Blue}	<span class="hljs-comment">//Color.Red 等于0</span>
<span class="hljs-keyword">let</span> c: Color = Color.Green		
<span class="hljs-comment">//c被定义为Color枚举类型，只能在被赋值为{Red, Green, Blue}中的一个，实际对应的是{0，1，2}</span>
<span class="hljs-keyword">enum</span> Color {Red=<span class="hljs-number">1</span>, Green=<span class="hljs-number">2</span>, Blue}	<span class="hljs-comment">//可以修改默认值</span>
<span class="hljs-keyword">let</span> c: Color = Color.Green	
</code></pre>
</li>
<li>
<p>类型断言?</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> someValue: <span class="hljs-built_in">any</span> = <span class="hljs-string">"hello !"</span>
<span class="hljs-keyword">let</span> strLength: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).length;
</code></pre>
</li>
</ol>
<h3 id="%E5%8F%98%E9%87%8F">变量</h3>
<ol>
<li>
<p>let与const，与es6相同</p>
</li>
<li>
<p>解构</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*数组解构*/</span>
<span class="hljs-keyword">let</span> input = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
<span class="hljs-keyword">let</span> [first,second] = input <span class="hljs-comment">//声明了两个变量</span>
[first,second] = [second,first] <span class="hljs-comment">//变量交换</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">[p1,p2]</span>)</span>{<span class="hljs-comment">/*...*/</span>}	<span class="hljs-comment">//传入一个数组，在函数内部生成两个变量，p1、p2</span>
<span class="hljs-keyword">let</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];	<span class="hljs-comment">//剩余变量，rest 相当于[2,3,4]</span>
</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*对象解构*/</span>
<span class="hljs-keyword">let</span> o = {a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>};
<span class="hljs-keyword">let</span> {a,b} = o;
<span class="hljs-keyword">let</span> {a = <span class="hljs-number">100</span>, b} = o;	<span class="hljs-comment">//默认值</span>
<span class="hljs-keyword">let</span> {a,...r} = o; <span class="hljs-comment">//剩余变量，r = {b: 2，c: 3}</span>
<span class="hljs-keyword">let</span> { a: one, b: two } = o;	<span class="hljs-comment">//属性重命名</span>
<span class="hljs-keyword">let</span> { a: one, b: two }:{a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span>} = o;	<span class="hljs-comment">//设置类型</span>
<span class="hljs-comment">/*函数声明*/</span>
<span class="hljs-keyword">type</span> C = { a: <span class="hljs-built_in">string</span>, b?: <span class="hljs-built_in">number</span> }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">{ a, b }: C</span>): <span class="hljs-title">void</span> </span>{<span class="hljs-comment">/*.......*/</span>} 
<span class="hljs-comment">//传入一个C类型的对象，在函数内部生成a、b两个变量</span>
</code></pre>
</li>
<li>
<p>展开</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*数组展开*/</span>
<span class="hljs-keyword">let</span> ar = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, ...ar]
<span class="hljs-comment">/*对象展开*/</span>
<span class="hljs-keyword">let</span> o = {b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>}
<span class="hljs-keyword">let</span> oo = {a: <span class="hljs-number">1</span>, ...o}
<span class="hljs-comment">// 出现在展开对象后面的属性会覆盖前面的属性。</span>
<span class="hljs-comment">//对象展开仅包含对象自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法</span>
</code></pre>
</li>
</ol>
<h3 id="%E6%8E%A5%E5%8F%A3">接口</h3>
<ol>
<li>
<p>概念：typescript的接口像是一种对<strong>对象</strong>结构的描述，像是一种自定义类型，将一个变量声明为该接口类型时，此变量的值就必须满足接口的描述，否则将编译不过</p>
</li>
<li>
<p>可选属性，但一个接口定义的属性可有可无时，可以将其定义为可选类型，来避免编译报错</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*必选*/</span>
<span class="hljs-keyword">interface</span> SquareConfig {
  color: <span class="hljs-built_in">string</span>;
  width: <span class="hljs-built_in">number</span>;
}
<span class="hljs-comment">/*可选*/</span>
<span class="hljs-keyword">interface</span> SquareConfig {
  color?: <span class="hljs-built_in">string</span>;
  width?: <span class="hljs-built_in">number</span>;
}
</code></pre>
</li>
<li>
<p>只读属性：一些对象属性只能在对象刚刚创建的时候修改其值，其他时间是不允许修改的</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Point {
    readonly x: <span class="hljs-built_in">number</span>;	<span class="hljs-comment">//用readonly来定义只读属性</span>
    readonly y: <span class="hljs-built_in">number</span>;
}
<span class="hljs-comment">/*只读数组 ReadonlyArray&lt;T&gt;*/</span>
<span class="hljs-keyword">let</span> a: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">let</span> ro: ReadonlyArray&lt;<span class="hljs-built_in">number</span>&gt; = a;
ro[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>; <span class="hljs-comment">// error!</span>
ro.push(<span class="hljs-number">5</span>); <span class="hljs-comment">// error!</span>
ro.length = <span class="hljs-number">100</span>; <span class="hljs-comment">// error!</span>
a = ro; <span class="hljs-comment">// error!</span>
</code></pre>
<p>对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 <strong>如果一个对象字面量</strong>存在任何“<strong>目标类型</strong>”不包含的属性时，你会得到一个错误。</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*绕开检查*/</span>
<span class="hljs-keyword">let</span> mySquare = createSquare({ width: <span class="hljs-number">100</span>, opacity: <span class="hljs-number">0.5</span> } <span class="hljs-keyword">as</span> SquareConfig);
</code></pre>
</li>
<li>
<p>可索引的类型: 共支持两种索引签名<strong>字符串</strong> 、<strong>数字</strong></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> StringArray {
  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">let</span> myArray: StringArray = [<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Fred"</span>];
<span class="hljs-comment">/* 错误：使用'string'索引，有时会得到number!*/</span>
<span class="hljs-keyword">interface</span> NotOkay {	
    [x: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;	<span class="hljs-comment">//数字索引会转化为字符串索引，比如100或转化为"100"</span>
    [x: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> NumberDictionary {
  	[index: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;
  	length: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// 可以，length是number类型</span>
  	name: <span class="hljs-built_in">string</span>       <span class="hljs-comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span>
}
<span class="hljs-comment">/*只读*/</span>
<span class="hljs-keyword">interface</span> ReadonlyStringArray {
    readonly [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//防止给索引赋值</span>
}
</code></pre>
</li>
<li>
<p>函数类型</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> SearchFunc {
    (source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;	
	<span class="hljs-comment">//(参数1:参数1类型,参2数: 参数2类型): 返回类型</span>
}
<span class="hljs-keyword">let</span> mysearch: SearchFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s1:<span class="hljs-built_in">string</span>,s2:<span class="hljs-built_in">string</span></span>)</span>{
    <span class="hljs-comment">//balabala.....</span>
    <span class="hljs-comment">//函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre>
</li>
<li>
<p>继承接口，extends 接口1, 接口2</p>
</li>
<li>
<p>接口继承类：当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。</p>
<p><strong>接口继承类形成的接口，实现该接口的类必须且只能是 <u>被继承类</u> 的子类</strong></p>
</li>
</ol>
<h3 id="%E7%B1%BB">类</h3>
<h5 id="%E7%BB%A7%E6%89%BF">继承</h5>
<p>子类继承基类的public、protected属性和方法，</p>
<ol>
<li>在子类中可以通过this.xxx访问到xxx属性或方法，</li>
<li>子类的构造函数内必须首先执行基类的构造方法,通过执行super()</li>
<li>子类可以重写基类的方法，重写(xxx)后还是可以通过super.xxx() 访问到基类的方法。</li>
</ol>
<h5 id="%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9">类型兼容</h5>
<ol>
<li>两个类都没有public、protected的属性和方法，而且具有相同的公有属性和方法，那这两个类是兼容的，</li>
<li>两个类都继承自一个基类并且有与上述一样的情况，那这两个类是兼容的</li>
<li>兼容的类的实例值可互换。</li>
</ol>
<h5 id="%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">访问控制</h5>
<ol>
<li>private ：不能在类外部使用，也不能在子类直接使用，子类只能通过基类的public、和protected方法间接访问，类的外部只能通过类实例的方法来间接访问私有的属性或方法</li>
<li>protected：不能在类外部使用，能继承给子类，子类可直接通过this.xxx访问的到protected的方法或属性</li>
<li>public：默认</li>
</ol>
<h5 id="%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7">只读属性</h5>
<p>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<h5 id="%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7">参数属性</h5>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>) { } <span class="hljs-comment">//自动赋值了</span>
    move(distanceInMeters: <span class="hljs-built_in">number</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${this.name}</span> moved <span class="hljs-subst">${distanceInMeters}</span>m.`</span>);
    }
}
</code></pre>
<h5 id="%E5%AD%98%E5%8F%96%E5%99%A8">存取器</h5>
<ol>
<li>get name(){}</li>
<li>set name(str){}</li>
</ol>
<h5 id="%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7">静态属性</h5>
<p>用static修饰属性，该属性是属于类的，实在类建立时初始化的，而不是创建实例时，可以同过 <strong>类名.xxx</strong> 直接访问，所有的子类可共享该属性。</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/typeScript.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/VUE.html">VUE</a></h3>
        <div class="preview md_html">
            <h3 id="%E6%A6%82%E5%BF%B5">概念</h3>
<h4 id="%E9%A6%96%E5%85%88vue%E5%AE%9E%E4%BE%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">首先vue实例是什么？</h4>
<p>首先是一个js对象，负责管理视图数据，视图的渲染根据的是vue实例data，而视图上的动作可以与vue实例的方法绑定从而修改data，这就是一个双向的过程。</p>
<p>那么html模板的作用就明显了，vue实例需要绑定到html元素上才会起作用，所以html模板就是通过vue实例提供的数据与方法来动态渲染视图。</p>
<h4 id="vue%E7%BB%84%E4%BB%B6">vue组件</h4>
<p>将vue实例与html模板组合在一块，就可以组成一个既可以管理自身状态又可以与外界交互的vue组件。（当然对于一个vue组件来说vue实例并不是必要的）</p>
<h4 id="vue%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">vue实例生命周期</h4>
<p>vue实例从创建到销毁会经历一系列的阶段，在这些阶段会执行不同的方法，通过重写这些方法来在不同阶段执行一些特定的任务。</p>
<p><strong>beforeCreate</strong> -&gt; created -&gt; beforeMount -&gt; mounted -&gt; beforeUpdate -&gt; updated -&gt; <strong>destroyed</strong></p>
<h4 id="%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95">模板语法</h4>
<h5 id="%E6%8F%92%E5%80%BC">插值</h5>
<ol>
<li>
<p>文本</p>
<p>​</p>
<pre><code class="hljs language-vue">&lt;span&gt;Message: {{ msg }}&lt;/span&gt;
</code></pre>
</li>
<li>
<p>原始HTML</p>
<pre><code class="hljs language-vue">&lt;p&gt;Using mustaches: {{ rawHtml }}&lt;/p&gt;
&lt;p&gt;
  	Using v-html directive: 
  	&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
</code></pre>
</li>
<li>
<p>html特性</p>
<p>给html设置特性时，</p>
</li>
</ol>
<h4 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4">自定义指令</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//全局</span>
Vue.directive(<span class="hljs-string">'focus'</span>, {
  <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span>
  inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-comment">// 聚焦元素</span>
    el.focus()
  }
})
<span class="hljs-comment">//局部</span>
directives: {
  <span class="hljs-attr">focus</span>: {
    <span class="hljs-comment">// 指令的定义</span>
    inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{
      el.focus()
    }
  }
}
<span class="hljs-comment">//使用，focus时将自动获得焦点</span>
&lt;input v-focus&gt;
</code></pre>
<h5 id="%E6%8C%87%E4%BB%A4%E9%92%A9%E5%AD%90">指令钩子</h5>
<ul>
<li>bind: 只调用一次，指令第一次绑定到元素时调用</li>
<li>inserted：被绑定元素插入父节点时调用</li>
<li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。</li>
<li>componentUpdate：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li>unbind：只调用一次，指令与元素解绑时调。</li>
</ul>
<h5 id="%E6%8C%87%E4%BB%A4%E9%92%A9%E5%AD%90%E5%8F%82%E6%95%B0">指令钩子参数</h5>
<ul>
<li>el：指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li>binding：一个对象
<ul>
<li>name:指令名，不带 v-</li>
<li>value：指令值</li>
<li>oldValue：上一个之指令值</li>
<li>expression：字符串形式的指令表达式</li>
<li>arg：传给指令的参数，可选</li>
<li>modifiers：一个包含修饰符的对象。</li>
</ul>
</li>
<li>vnode：Vue编译生成的虚拟节点</li>
<li>oldVnode：上一个虚拟节点，仅在update和componentUpdated钩子中可用</li>
</ul>
<h4 id="%E8%BF%87%E6%BB%A4%E5%99%A8-vue.filter">过滤器 Vue.filter</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//全局</span>
Vue.filter(<span class="hljs-string">'my-filter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
  <span class="hljs-comment">// 返回处理后的值</span>
})
<span class="hljs-comment">//局部</span>
filters: {
  <span class="hljs-string">"my-filter"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-comment">// 返回处理后的值</span>
  }
}
<span class="hljs-comment">//使用</span>
<span class="hljs-comment">// 在双花括号中</span>
{{ data | myFilter }}
<span class="hljs-comment">// 在 `v-bind` 中</span>
&lt;div v-bind:id=<span class="hljs-string">"rawId | myFilter"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="hljs-comment">//接受参数。filterA接受的参数 message、arg1、arg2</span>
{{ message | filterA(<span class="hljs-string">'arg1'</span>, arg2) }}
</code></pre>
<h4 id="%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6-vue.component">全局组件 Vue.component</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 注册组件，传入一个扩展过的构造器</span>
Vue.component(<span class="hljs-string">'my-component'</span>, Vue.extend({ <span class="hljs-comment">/* ... */</span> }))

<span class="hljs-comment">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span>
Vue.component(<span class="hljs-string">'my-component'</span>, { <span class="hljs-comment">/* ... */</span> })

<span class="hljs-comment">// 获取注册的组件 (始终返回构造器)</span>
<span class="hljs-keyword">var</span> MyComponent = Vue.component(<span class="hljs-string">'my-component'</span>)
</code></pre>
<h4 id="%E6%8F%92%E4%BB%B6-vue.use(-plugin-)">插件 Vue.use( plugin )</h4>
<p>安装Vue插件，为vue添加全局功能，{Object | Function} plugin，如果是Object 必须提供install方法，如果是Function则直接当作install方法。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//定义插件</span>
MyPlugin.install = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) </span>{
  <span class="hljs-comment">// 1. 添加全局方法或属性</span>
  Vue.myGlobalMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 逻辑...</span>
  }

  <span class="hljs-comment">// 2. 添加全局资源</span>
  Vue.directive(<span class="hljs-string">'my-directive'</span>, {
    bind (el, binding, vnode, oldVnode) {
      <span class="hljs-comment">// 逻辑...</span>
    }
    ...
  })

  <span class="hljs-comment">// 3. 注入组件</span>
  Vue.mixin({
    <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">// 逻辑...</span>
    }
    ...
  })

  <span class="hljs-comment">// 4. 添加实例方法</span>
  Vue.prototype.$myMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">methodOptions</span>) </span>{
    <span class="hljs-comment">// 逻辑...</span>
  }
}
<span class="hljs-comment">//注册插件</span>
Vue.use(MyPlugin, { <span class="hljs-attr">someOption</span>: <span class="hljs-literal">true</span> })
<span class="hljs-comment">//使用....</span>
</code></pre>
<h4 id="%E5%85%A8%E5%B1%80%E6%B7%B7%E5%90%88-mixin">全局混合 mixin</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 为自定义的选项 'myOption' 注入一个处理器。</span>
Vue.mixin({
  <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> myOption = <span class="hljs-keyword">this</span>.$options.myOption
    <span class="hljs-keyword">if</span> (myOption) {
      <span class="hljs-built_in">console</span>.log(myOption)
    }
  }
})

<span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">myOption</span>: <span class="hljs-string">'hello!'</span>
})
<span class="hljs-comment">// =&gt; "hello!"</span>
</code></pre>
<p>自定义选项合并策略 Vue.config.optionMergeStrategies.myOption = function..</p>
<h4 id="%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0render">渲染函数render</h4>
<p>render函数的作用是来代替模板语法，当模板语法过于冗长，而且根据业务场景无法删减时，建议使用render。</p>
<p>render函数可以在定义组件时使用，也可以在渲染数据时使用（在渲染时对数据加工，修改外观、行为等，而不是单纯的数据渲染）</p>
<p>render函数第一个函数必须是 <strong>createElement</strong> 函数（别名 <strong>h</strong>），其他参数随意</p>
<p><strong>createElement</strong> 函数参数结构与dom节点树类似，第一个参数是一个字符串作为元素标签名，第二个参数是一个节点配置项（js对象），第三个参数是一个节点数组，节点可以是任意类型，所以可以嵌套<strong>createElement</strong> 来构造复杂的节点数。</p>
<p>配置项对象</p>
<pre><code class="hljs language-javascript">{
  <span class="hljs-comment">// 和`v-bind:class`一样的 API</span>
  <span class="hljs-string">'class'</span>: {
    <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-comment">// 和`v-bind:style`一样的 API</span>
  style: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'14px'</span>
  },
  <span class="hljs-comment">// 正常的 HTML 特性</span>
  attrs: {
    <span class="hljs-attr">id</span>: <span class="hljs-string">'foo'</span>
  },
  <span class="hljs-comment">// 组件 props</span>
  props: {
    <span class="hljs-attr">myProp</span>: <span class="hljs-string">'bar'</span>
  },
  <span class="hljs-comment">// DOM 属性</span>
  domProps: {
    <span class="hljs-attr">innerHTML</span>: <span class="hljs-string">'baz'</span>
  },
  <span class="hljs-comment">// 事件监听器基于 `on`</span>
  <span class="hljs-comment">// 所以不再支持如 `v-on:keyup.enter` 修饰器</span>
  <span class="hljs-comment">// 需要手动匹配 keyCode。</span>
  on: {
    <span class="hljs-attr">click</span>: <span class="hljs-keyword">this</span>.clickHandler
  },
  <span class="hljs-comment">// 仅对于组件，用于监听原生事件，而不是组件内部使用 `vm.$emit` 触发的事件。</span>
  nativeOn: {
    <span class="hljs-attr">click</span>: <span class="hljs-keyword">this</span>.nativeClickHandler
  },
  <span class="hljs-comment">// 自定义指令。注意，您无法对绑定中的 `oldValue` 赋值</span>
  <span class="hljs-comment">// Vue 会为您持续追踪</span>
  directives: [
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'my-custom-directive'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'2'</span>,
      <span class="hljs-attr">expression</span>: <span class="hljs-string">'1 + 1'</span>,
      <span class="hljs-attr">arg</span>: <span class="hljs-string">'foo'</span>,
      <span class="hljs-attr">modifiers</span>: {
        <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span>
      }
    }
  ],
  <span class="hljs-comment">// Scoped slots in the form of</span>
  <span class="hljs-comment">// { name: props =&gt; VNode | Array&lt;VNode&gt; }</span>
  scopedSlots: {
    <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> createElement(<span class="hljs-string">'span'</span>, props.text)
  },
  <span class="hljs-comment">// 如果组件是其他组件的子组件，需为插槽指定名称</span>
  slot: <span class="hljs-string">'name-of-slot'</span>,
  <span class="hljs-comment">// 其他特殊顶层属性</span>
  key: <span class="hljs-string">'myKey'</span>,
  <span class="hljs-attr">ref</span>: <span class="hljs-string">'myRef'</span>
}
</code></pre>
<h3 id="%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9">配置选项</h3>
<h4 id="%E6%95%B0%E6%8D%AE">数据</h4>
<h5 id="data">data</h5>
<ul>
<li><strong>类型</strong>：<code>Object | Function</code></li>
<li><strong>限制</strong>：组件的定义只接受 <code>function</code>。</li>
</ul>
<blockquote>
<p>Vue 实例的数据对象。Vue 将会递归将 data 的属性<strong>转换为 getter/setter</strong>，从而让 data 的属性能够响应数据变化。<strong>对象必须是纯粹的对象</strong> (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</p>
</blockquote>
<blockquote>
<p>以 <code>_</code> 或 <code>$</code> 开头的属性 <strong>不会</strong> 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。</p>
</blockquote>
<p>注意：不应使用箭头函数</p>
<h5 id="props">props</h5>
<p><strong>详情</strong> : <strong>props</strong> 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 对象语法，提供校验</span>
Vue.component(<span class="hljs-string">'props-demo-advanced'</span>, {
  <span class="hljs-attr">props</span>: {
    <span class="hljs-comment">// 检测类型</span>
    height: <span class="hljs-built_in">Number</span>,
    <span class="hljs-comment">// 检测类型 + 其他验证</span>
    age: {
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">0</span>
      }
    }
  }
})
</code></pre>
<h5 id="propsdata">propsData</h5>
<p>用于通过 new 创建实例时传递 props</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Comp = Vue.extend({
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'msg'</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;{{ msg }}&lt;/div&gt;'</span>
})

<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Comp({
  <span class="hljs-attr">propsData</span>: {
    <span class="hljs-attr">msg</span>: <span class="hljs-string">'hello'</span>
  }
})
</code></pre>
<h5 id="computed">computed</h5>
<p>计算属性，属性值必须是个函数，或者是一个具有get、set方法的对象，计算属性的结果会被缓存，是有实例内的相应式数据会触发它的重新计算，其他的变化都不会？？</p>
<h5 id="methods">methods</h5>
<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。</p>
<h5 id="watch">watch</h5>
<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>
  },
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'new: %s, old: %s'</span>, val, oldVal)
    },
    <span class="hljs-comment">// 方法名</span>
    b: <span class="hljs-string">'someMethod'</span>,
    <span class="hljs-comment">// 深度 watcher</span>
    c: {
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>{ <span class="hljs-comment">/* ... */</span> },
      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-comment">// 该回调将会在侦听开始之后被立即调用</span>
    d: {
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>{ <span class="hljs-comment">/* ... */</span> },
      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>
    }
  }
})
vm.a = <span class="hljs-number">2</span> <span class="hljs-comment">// =&gt; new: 2, old: 1</span>
</code></pre>
<h4 id="dom">DOM</h4>
<p>vue实例最终是要挂载到DOM节点上才会起作用，实例如何挂载到DOM节点？可以通过el、template、tender、renderError等属性来配置。</p>
<h5 id="el">el</h5>
<p>在由new创建实例时使用，可以是css选择器，或者HTMLElement实例</p>
<h5 id="template">template</h5>
<p>一个字符串模板作为vue实例的标识使用。</p>
<h5 id="render">render</h5>
<p>直接使用render函数传入的createElement来构造节点树</p>
<h5 id="rendererroe">renderErroe</h5>
<p>....</p>
<h4 id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">生命周期钩子</h4>
<h4 id="%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">实例属性</h4>
<ul>
<li>
<p><strong>vm.$slots</strong> : 用来访问被插槽分发的内容。(slot=&quot;foo&quot; 中的内容将会在 vm.$slots.foo 中被找到),default 属性包括了所有没有被包含在具名插槽中的节点。</p>
</li>
<li>
<p><strong>vm.$refs</strong> : 持有已注册过ref的所有子组件</p>
<pre><code class="hljs language-javascript">
</code></pre>
<p>​</p>
</li>
</ul>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/VUE.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/vuepress.html">vuepress</a></h3>
        <div class="preview md_html">
            <h2 id="%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><a href="https://vuepress.vuejs.org/zh/config/" title="官方地址">配置文件</a></h2>
<p>配置文件一般存放在文档根目录下面的.vuepress/config.js里面。</p>
<h3 id="%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">基本配置</h3>
<h4 id="base">base</h4>
<p><code>type: string</code></p>
<p>默认值是 <code>'/'</code>, 配置文档的基本URL，必须以斜杆开始和结束</p>
<h4 id="title">title</h4>
<p><code>tpye: string</code></p>
<p>没有默认值，这是所有页面标题的前缀。</p>
<h4 id="description">description</h4>
<p>网站的描述，以<code>&lt;meta&gt;</code> 标签渲染到当前页面的html中</p>
<h4 id="head">head</h4>
<p><code>type: Array</code> ,</p>
<p>注入额外的标签到<code>&lt;head&gt;</code>中，每个标签都可以以<code>[tagName,{ attrName: attrValue},innnerHTML</code>的格式指定</p>
<h4 id="host">host</h4>
<p>指定dev server的主机名</p>
<h4 id="port">port</h4>
<p>指定dev server的端口</p>
<h4 id="dest">dest</h4>
<p>指定vuepress build 的输出目录</p>
<h4 id="ga">ga</h4>
<p>提供 Google AnalyticsID 来开启集成。？</p>
<h4 id="serviceworker">serviceWorker</h4>
<p>如果设置为 true，VuePress 将自动生成并注册一个 service worker ，这个 worker 将内容缓存以供离线使用（仅在生产环境中启用）。</p>
<h3 id="%E4%B8%BB%E9%A2%98%E5%8C%96">主题化</h3>
<h4 id="theme">theme</h4>
<p><code>type: string</code> ,默认值<code>undefined</code></p>
<p>指定此选项来使用自定义主题。使用 “foo” 的值，VuePress 将尝试在 <code>node_modules/vuepress-theme-foo/Layout.vue</code> 加载主题组件。</p>
<h4 id="themeconfig">themeConfig</h4>
<p><code>type: Object</code>, 默认值 {}</p>
<p>为使用的主题提供配置选项。这些选项将根据你使用的主题而有所不同。</p>
<h3 id="markdown">Markdown</h3>
<h4 id="markdown.linenumbers">markdown.lineNumbers</h4>
<p><code>type: boolean</code></p>
<p>是否在每个代码块的左侧显示行号</p>
<h4 id="markdown.anchor">markdown.anchor</h4>
<p><code>type: Object</code>, 默认值：<code>{ permalink: true, permalinkBefore: true, permalinkSymbol: '#' }</code> ,<a href="https://github.com/valeriangalliat/markdown-it-anchor">markdown-it-anchor</a> 的选项。?配置锚点?</p>
<h4 id="markdown.externallinks">markdown.externalLinks</h4>
<p><code>type: Object</code> ,默认值：<code>{ target: '_blank', rel: 'noopener noreferrer' }</code> 。这个键值对将会作为特性被增加到是外部链接的 <code>&lt;a&gt;</code> 标签上，默认的选项将会在新窗口中打开一个该外部链接。</p>
<h4 id="markdown.toc">markdown.toc</h4>
<p><code>type: Object</code> ,默认值：<code>{ includeLevel: [2, 3] }</code> 。<a href="https://github.com/Oktavilla/markdown-it-table-of-contents">markdown-it-table-of-contents</a> 的选项</p>
<h4 id="markdown.config">markdown.config</h4>
<p><code>type: Function</code>, 默认值<code>undefined</code> ，一个用于修改当前的 <a href="https://github.com/markdown-it/markdown-it">markdown-it</a> 实例的默认配置，或者应用额外的插件的函数。</p>
<h3 id="%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B">构建流程</h3>
<h4 id="loader(postcss%E3%80%81stylus%E3%80%81scss%E3%80%81sass%E3%80%81less)">loader(postcss、stylus、scss、sass、less)</h4>
<p>对应的相应的webpack的loader配置。</p>
<ul>
<li>postcss -&gt; <code>{ plugins: [require('autoprefixer')] }</code></li>
<li>stylus -&gt; <code>{ preferPathResolver: 'webpack' }</code></li>
<li>scss -&gt; <code>{}</code></li>
<li>sass -&gt; <code>{ indentedSyntax: true }</code></li>
<li>less -&gt; <code>{}</code></li>
</ul>
<h4 id="configurewebpack">configureWebpack</h4>
<p><code>type: Object | Function</code>，默认值<code>undefined</code>，用于修改内部的 Webpack 配置。如果给定一个对象，那么它将会被 <a href="https://github.com/survivejs/webpack-merge">webpack-merge</a> 合并到最终的配置中，如果给定一个函数，它将会接受 <code>config</code> 作为第一个参数，以及 <code>isServer</code> 作为第二个参数，你可以直接更改 <code>config</code>，也可以返回一个待合并的对象。</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">configureWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config, isServer</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!isServer) {
      <span class="hljs-comment">// 修改客户端的 webpack 配置</span>
    }
  }
}
</code></pre>
<h4 id="chainwebpack">chainWebpack</h4>
<p><code>type: Function</code> , 默认值 <code>undefined</code> 通过 <a href="https://github.com/mozilla-neutrino/webpack-chain">webpack-chain</a> 来修改内部的 Webpack 配置。</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config, isServer</span>) =&gt;</span> {
    <span class="hljs-comment">// config 是 ChainableConfig 的一个实例</span>
  }
}
</code></pre>
<h3 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">浏览器兼容性</h3>
<h4 id="evergreen">evergreen</h4>
<p><code>type: boolean</code>, 默认值 <code>false</code>, 如果你的对象只有那些 “常青树” 浏览器，你可以将其设置成 <code>true</code>，这将会禁止 ESNext 到 ES5 的转译以及对 IE 的 polyfills，同时会带来更快的构建速度和更小的文件体积。</p>
<h3 id="%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5">相关链接</h3>
<p><a href="https://vuepress.vuejs.org/zh/default-theme-config/">默认主题配置</a></p>
<h2 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98"><a href="https://vuepress.vuejs.org/zh/guide/custom-themes.html">自定义主题</a></h2>
<p>vuePress 使用单文件组件来构建自定义主题。想要开发一个自定义主题，首先在你的文档根目录新建一个 <code>.vuepress/theme</code> 文件夹，然后再创建一个 <code>Layout.vue</code> 文件。theme组件相当于一个容器组件，转化为vue组件的md文件包裹起来，同时theme组件可以过去的到整个站点和当前页面的元数据。</p>
<pre><code class="hljs language-flow">st=&gt;start: ***.md
mdToVue=&gt;operation: 将md文件转化为一个vue组件
injectToLayout=&gt;operation: 将md组件作为一个独特的全局组件&lt;Content /&gt;来使用
st-&gt;mdToVue-&gt;injectToLayout
</code></pre>
<pre><code class="hljs language-vue">&lt;template&gt;
  &lt;div class=&quot;theme-container&quot;&gt;
    &lt;Content/&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/vuepress.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/webpack.html">webpack</a></h3>
        <div class="preview md_html">
            <h3 id="%E5%85%A5%E5%8F%A3">入口</h3>
<h4 id="%E5%8D%95%E5%85%A5%E5%8F%A3">单入口</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//简写</span>
<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./path/to/my/entry/file.js'</span>
};
<span class="hljs-built_in">module</span>.exports = config
<span class="hljs-comment">//对象写法</span>
<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">main</span>: <span class="hljs-string">'./path/to/my/entry/file.js'</span>
  }
};
</code></pre>
<p>多入口（多页面）</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//告诉webpack 需要构建 3 个独立分离的依赖图</span>
<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">pageOne</span>: <span class="hljs-string">'./path/to/my/one.js'</span>,
    <span class="hljs-attr">pageTwo</span>: <span class="hljs-string">'./path/to/my/two.js'</span>
  }
};
</code></pre>
<h3 id="%E8%BE%93%E5%87%BA">输出</h3>
<p><strong>注意</strong> ：即使可以存在多个入口起点，但只指定一个输出配置</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//创建单个chunk</span>
<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>:<span class="hljs-string">'bundle.js'</span>	<span class="hljs-comment">//输出文件名</span>
    path:<span class="hljs-string">'/home/proj/public/assets'</span>	<span class="hljs-comment">//输出路径</span>
  }
}
<span class="hljs-comment">//创建多个chunk</span>
{
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">app</span>: <span class="hljs-string">'./src/app.js'</span>,
    <span class="hljs-attr">search</span>: <span class="hljs-string">'./src/search.js'</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].js'</span>,	<span class="hljs-comment">//[name]代表入口文件名称</span>
    path: __dirname + <span class="hljs-string">'/dist'</span>	<span class="hljs-comment">//__dirname魔术变量</span>
  }
}
</code></pre>
<h3 id="loader">loader</h3>
<p>用于对模块的源代码进行转换。处理时机是 import 或加载模块时</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//简写模式</span>
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      { <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'css-loader'</span> },<span class="hljs-comment">//test文件匹配规则 </span>
      { <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'ts-loader'</span> }	<span class="hljs-comment">//use使用的loader插件 ，字符串或对象数组</span>
    ]
  }
};
<span class="hljs-comment">//详细模式</span>
  <span class="hljs-built_in">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [
          { <span class="hljs-attr">loader</span>: <span class="hljs-string">'style-loader'</span> },
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'css-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">modules</span>: <span class="hljs-literal">true</span>
            }
          }
        ]
      }
    ]
  }
</code></pre>
<ul>
<li>支持链式传递（给use属性传递一个数组），前一个loader将处理结果传递给下个loader处理</li>
<li>loader支持同步或异步</li>
<li>能接受查询参数？？</li>
<li>可以通过options对象进行配置</li>
<li>loader能够产生额外的任意文件</li>
</ul>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/webpack.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/webpack插件与loader.html">webpack插件与loader</a></h3>
        <div class="preview md_html">
            <h3 id="%E5%8E%BB%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB%E6%8F%92%E4%BB%B6">去代码分离插件</h3>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">new</span> webpack.optimize.CommonChunkPlugin({	<span class="hljs-comment">//自带的去重插件</span>
	name: <span class="hljs-string">'common'</span> <span class="hljs-comment">//指定公共bundle 的名称</span>
})
</code></pre>
<p>ExtractTextPlugin:用于将css从主应用程序中分离</p>
<p>bundle-loader:</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/webpack插件与loader.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/webpack配置情景.html">webpack配置情景</a></h3>
        <div class="preview md_html">
            <h4 id="1.-%E4%BD%BFcss%E3%80%81less%E6%94%AF%E6%8C%81%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%AE%A1%E7%90%86%E3%80%81%E5%90%88%E5%B9%B6%E6%89%93%E5%8C%85%E5%88%B0%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6">1. 使css、less支持模块引入、作用域管理、合并打包到单个文件</h4>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/webpack配置情景.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/yarn.html">yarn</a></h3>
        <div class="preview md_html">
            <h4 id="add">add</h4>
<ul>
<li><strong>yarn add  &lt;package...&gt;  [--dev/-D, --peer/-P, --optional/-O, --exact/-E, --tilde/-T]</strong></li>
</ul>
<h4 id="cache-*">cache  *</h4>
<ul>
<li><strong>yarn cache ls</strong>	    列出所有已经缓存的包。</li>
<li><strong>yarn cache dir</strong>         会打印出当前的 yarn 全局缓存在哪里</li>
<li><strong>yarn cache clean</strong>     清除本地缓存</li>
</ul>
<h4 id="check">check</h4>
<ul>
<li><strong>yarn check</strong>    校验当前项目的 package.json 文件里的依赖版本和 yarn 的 lock 文件中列出的版本是否匹配。</li>
<li><strong>yarn check --integrity</strong>  校验当前项目的 package.json 文件里列出的依赖包的版本以及此包的散列值是否与 yarn 的 lock 文件中列出的相应版本和散列（hash）值一致。 这有助于验证依赖包没有被篡改。</li>
</ul>
<h4 id="clean">clean</h4>
<p>清除安装失败的依赖包</p>
<h4 id="config">config</h4>
<ul>
<li><strong>yarn config set <key> <value> [-g|--global]</strong>    设置配置文件的key-value</li>
<li><strong>yarn config get <key></strong>    获取配置的文件中对应key的value</li>
<li><strong>yarn config delete <key></strong>    删除配置文件中某个key</li>
<li><strong>yarn config list</strong>    列出所有的配置信息</li>
</ul>
<h4 id="generate-lock-entry">generate-lock-entry</h4>
<p>此命令针对复杂的使用情况或业务。它所生成的 lock 文件用来作为当前的 package.json 文件的清单文件（manifest file）。</p>
<h4 id="global">global</h4>
<ul>
<li><strong>yarn global &lt;add/bin/ls/remove/upgrade&gt; [--prefix]</strong>   全局操作</li>
</ul>
<h4 id="info">info</h4>
<ul>
<li><strong>yarn info <package>  [<field>]</strong>    查看某个包的信息</li>
</ul>
<h4 id="init">init</h4>
<p>初始化一个yarn project</p>
<h4 id="yarn-%2F-yarn-install">yarn / yarn install</h4>
<p>yarn install --[ flat / force / har / no-lockfile / production / pure-lockfile ]</p>
<ul>
<li><strong>--force</strong>   强制重新安装package.json中的所有依赖</li>
<li><strong>--har</strong></li>
<li><strong>--no-lockfile</strong>    Don’t read or generate a yarn.lock lockfile.</li>
<li><strong>--production</strong>    will not install any package listed in devDependencies.</li>
<li><strong>--pure-lockfile</strong>   Don’t generate a yarn.lock lockfile.</li>
</ul>
<h4 id="licenses-ls">licenses ls</h4>
<p>执行此命令将按字母顺序列出所有被 yarn 或 yarn install 安装的包，并同时列出每个包所采用的许可证（和源代码的 URL 地址）</p>
<h4 id="link">link</h4>
<p>link 命令用于调试本地依赖包</p>
<ul>
<li><strong>yarn link</strong>	为当前目录下的项目添加一个链接</li>
<li><strong>yarn link  <package></strong>  将package关联到一个本地的链接上</li>
</ul>
<h4 id="unlink">unlink</h4>
<ul>
<li><strong>yarn unlink [ package ]</strong></li>
</ul>
<h4 id="login">login</h4>
<ul>
<li><strong>yarn login url</strong>	登陆npm仓库</li>
</ul>
<h4 id="logout">logout</h4>
<p>退出登陆</p>
<h4 id="list">list</h4>
<p>列出项目所有的依赖</p>
<h4 id="owner">owner</h4>
<ul>
<li><strong>yarn owner ls <package></strong></li>
<li><strong>yarn owner add <user> <package></strong></li>
<li><strong>yarn owner rm <user> <package></strong></li>
</ul>
<h4 id="pack">pack</h4>
<p>打包</p>
<ul>
<li><strong>yarn pack --filename <filename></strong></li>
</ul>
<h4 id="publish">publish</h4>
<p>发布</p>
<ul>
<li><strong>yarn publish [ tarball ]</strong>	Publishes the package defined by a .tgz gzipped tarball.
<ul>
<li>**yarn publish [folder] **Publishes the package contained in the specified folder. <folder>/package.json should specify the package details.</li>
</ul>
</li>
<li><strong>yarn publish --tag <tag></strong>     Provided a tag to yarn publish lets you publish packages with a specific tag.</li>
<li><strong>yarn publish --access &lt;public|restricted&gt;</strong>    The --access flag controls whether the npm registry publishes this package as a public package, or restricted.</li>
</ul>
<h4 id="remove">remove</h4>
<ul>
<li>yarn remove &lt;package...&gt;		移除一个依赖</li>
</ul>
<h4 id="run">run</h4>
<ul>
<li>yarn run [script][-- <code>&lt;args&gt;</code>]	执行一个脚本</li>
</ul>
<h4 id="self-update">self-update</h4>
<h4 id="upgrade">upgrade</h4>
<p>更新所有的依赖到最新稳定版本（based on the version range specified in the package.json file. ）</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/yarn.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/冲突解决流程.html">冲突解决流程</a></h3>
        <div class="preview md_html">
            <p>pull - fetch - merge - 修改文件 -</p>
<p>yarn --frozen-lockfile</p>
<p>push</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/冲突解决流程.html">Read</a>
            </div>
        </div>
    </section>
    
    <div class="page_box">
    <div class="page_pre">
        <a class="page_pre_item" class="" href="/articles/1.html">FIRST</a>
        <a class="page_pre_item" href="/articles/2.html">
            <i class="iconfont icon-previous"></i>
        </a>
    </div>
    <div class="page_num">
        
            <a href="/articles/1.html" class="page_num_item ">
                1
            </a>
        
            <a href="/articles/2.html" class="page_num_item ">
                2
            </a>
        
            <a href="/articles/3.html" class="page_num_item actived">
                3
            </a>
        
            <a href="/articles/4.html" class="page_num_item ">
                4
            </a>
        
    </div>
    <div class="page_next">
        <a class="page_next_item" href="/articles/4.html">
            <i class="iconfont icon-next"></i>
        </a>
        <a class="page_next_item" href="/articles/4.html">LAST</a>
    </div>
    </div>
</div>
    </div>
    <aside>
        <div class="profile_banner"></div>
        <div class="profile_logo">
        <img src="/assets/logo.png" alt="">
        </div>
        <div class="profile_name">
            qoxop
        </div>
        <div class="profile_motto">
            一只单身的帅狗, 打代码、打游戏、撸猫、无恶不做~
        </div>
        <div class="profile_info">
        <div>
            <div class="iconbox"><em class="iconfont icon-github"></em></div>
            <div class="icontext">github</div>
        </div>
        <div>
            <div class="iconbox"><em class="iconfont icon-resume"></em></div>
            <div class="icontext">resume</div>
        </div>
        <div>...</div>
        </div>
    </aside>
</div>
        </div>
        <footer></footer>
      </div>
</body>
</html>