<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="keywords" content=",,,,,,,,,">
    <title>qoxop | 首页(53)</title>
    <link rel="stylesheet" href="/assets/common.css">
    <link rel="stylesheet" href="/assets/articleList.css">
    <link href="/assets/monokai_sublime.min.css" rel="stylesheet">  
    <script async src="/assets/highlight.min.js"></script>
     
      <script src="/assets/hot_reload.js"></script>
    
</head>
<body>
    <article id="app">
        <header>
          <h1>张集伟的个人博客</h1>
          <div class="content_box header_inner">
            <div class="logo">
              <div class="logoImg">
                <img src="/assets/icon.png" alt="">
              </div>
              <div class="logoText">
                jiw
              </div>
            </div>
            <nav class="navigator">
              <ul>
                
                <li class="actived">
                    <a href="#">
                        HOME
                    </a>
                </li>
                
                <li class="">
                    <a href="/category.html">
                        CATEGORY
                    </a>
                </li>
                
                <li class="">
                    <a href="/tags.html">
                        标签
                    </a>
                </li>
                
                <li class="">
                    <a href="/link.html">
                        链接
                    </a>
                </li>
                
                <li class="">
                    <a href="/about.html">
                        关于我
                    </a>
                </li>
                
              </ul>
            </nav>
          </div>
        </header>
        <main id="main">
           <div class="content_box">
    <div id="left_content">
        <!-- 这里存放主要内容 -->
       <div class="article_list">
    
    <section class="article_item">
        <h3><a href="/后端开发/备注.html">备注</a></h3>
        <div class="preview md_html">
            
        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/后端开发/备注.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/Es6异步.html">Es6异步</a></h3>
        <div class="preview md_html">
            <h3 id="generator">Generator</h3>
<h4 id="%E5%9F%BA%E7%A1%80%E5%86%99%E6%B3%95">基础写法</h4>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gn</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"begin"</span>);
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'world'</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">'ending'</span>;
}
<span class="hljs-keyword">var</span> g = gn()	<span class="hljs-comment">//这里gn函数内的语句不会立即执行，而是返回一个遍历器对象Iterator </span>
g.next();	<span class="hljs-comment">//log-&gt;begin return-&gt;{value:'hello', done: false}</span>
g.next();	<span class="hljs-comment">//return-&gt;{value:'world', done: false}</span>
g.next();	<span class="hljs-comment">//return-&gt;{value:'ending', done: true}</span>
g.next();	<span class="hljs-comment">//return-&gt;{value:undefined, done: true}</span>
</code></pre>
<p>generator本身就是发生器的意思，就是generator函数可以生产一系列的状态。他的作用是可以让函数分步执行，同时还保留了<strong>作用域</strong>。</p>
<p>yield表达式其实是一个暂停标志，它的参数作为该状态下的返回值(next方法的返回值)。yield表达式默认不会产生值（或者说产生一个undefined），当yield表达式嵌入在另一个表达式中时，必须用括号包裹起来，同时被嵌入的表达式是被视作下一个状态的程序（包括yield本身也是），所以next方法可以传递一个参数，该参数会被当作yield表达是产出值。</p>
<h4 id="for...of">for...of</h4>
<p>for...of 循环可以自动遍历 Generator 函数时生成的Iterator对象，且不再需要调用next方法。当返回的对象中done属性为true时停止循环，所以return返回的值不会出现在for...of中</p>
<h4 id="generator.prototype.throw()">Generator.prototype.throw()</h4>
<p>抛出一个错误，然后可以在函数内部捕获，如果内部没有捕获代码（或者说数量不足），错误将由外部处理。可以接受一个参数，该参数会被catch语句接收。</p>
<h4 id="generator.prototype.return()">Generator.prototype.return()</h4>
<p>提前终止遍历器对象的状态，并返回给定的值（参数），如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;
}
<span class="hljs-keyword">var</span> g = numbers();
g.next() <span class="hljs-comment">// { value: 1, done: false }</span>
g.next() <span class="hljs-comment">// { value: 2, done: false }</span>
g.return(<span class="hljs-number">5</span>) <span class="hljs-comment">// { value: 3, done: false }</span>
g.next() <span class="hljs-comment">// { value: 5, done: true }</span>
</code></pre>
<h4 id="yield*-%E8%A1%A8%E8%BE%BE">yield* 表达</h4>
<p>相当于代码复制，</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'x'</span>;
  <span class="hljs-keyword">yield</span>* foo();
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'y'</span>;
}
<span class="hljs-comment">// 等同于</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'x'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'y'</span>;
}
</code></pre>
<h4 id="generator-%E5%87%BD%E6%95%B0%E7%9A%84this">Generator 函数的this</h4>
<p>Generator 函数总是返回一个遍历器而不是this，也不可以用new来调用。</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.b = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.c = <span class="hljs-number">3</span>;
}
<span class="hljs-keyword">var</span> f = F.call(F.prototype);

f.next();  <span class="hljs-comment">// Object {value: 2, done: false}</span>
f.next();  <span class="hljs-comment">// Object {value: 3, done: false}</span>
f.next();  <span class="hljs-comment">// Object {value: undefined, done: true}</span>

f.a <span class="hljs-comment">// 1</span>
f.b <span class="hljs-comment">// 2</span>
f.c <span class="hljs-comment">// 3</span>
</code></pre>
<h4 id="%E5%BA%94%E7%94%A8">应用</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//状态机</span>
<span class="hljs-keyword">var</span> clock = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Tick!'</span>);
    <span class="hljs-keyword">yield</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Tock!'</span>);
    <span class="hljs-keyword">yield</span>;
  }
};
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//异步操作的同步化表示</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">yield</span> request(<span class="hljs-string">"http://some.url"</span>);
  <span class="hljs-keyword">var</span> resp = <span class="hljs-built_in">JSON</span>.parse(result);
    <span class="hljs-built_in">console</span>.log(resp.value);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url</span>) </span>{
  makeAjaxCall(url, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>{
    it.next(response);
  });
}
<span class="hljs-keyword">var</span> it = main();
it.next();
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">iterEntries</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(obj);	<span class="hljs-comment">//获取对象的所有key（字符串数组）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt; keys.length; i++) {
    <span class="hljs-keyword">let</span> key = keys[i];
    <span class="hljs-keyword">yield</span> [key, obj[key]];
  }
}
<span class="hljs-keyword">let</span> myObj = { <span class="hljs-attr">foo</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">7</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> iterEntries(myObj)) {
  <span class="hljs-built_in">console</span>.log(key, value);
}
</code></pre>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/Es6异步.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/Eslint相关.html">Eslint相关</a></h3>
        <div class="preview md_html">
            <h1 id="eslint">ESlint</h1>
<h3 id="%E5%AE%9A%E4%B9%89">定义</h3>
<p>ESLint 是一个开源的 JavaScript 代码检查工具</p>
<h3 id="%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8">安装使用</h3>
<pre><code class="hljs language-javascript">npm i -g eslint
</code></pre>
<ul>
<li>
<p>命令行使用</p>
<pre><code class="hljs">eslint [options] [<span class="hljs-keyword">file</span>|<span class="hljs-keyword">dir</span>|<span class="hljs-keyword">glob</span>]*

</code></pre>
</li>
<li>
<p>与编辑器一起配置使用，安装eslint插件</p>
</li>
</ul>
<h3 id="%E9%85%8D%E7%BD%AE">配置</h3>
<h5 id="%E6%B3%A8%E9%87%8A%E9%85%8D%E7%BD%AE">注释配置</h5>
<h5 id="%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE">文件配置</h5>
<p>在.eslintrc.*（json,js,yaml）文件 或者在package.json文件中的eslintConfig字段配置</p>
<ul>
<li>
<p>代码和解析</p>
<pre><code class="hljs language-json"><span class="hljs-string">"eslintConfig"</span>: {
    //配置解析器
    <span class="hljs-attr">"parser"</span>: <span class="hljs-string">"babel-eslint"</span>,
        
    //配置解析的选项
    <span class="hljs-attr">"parserOptions"</span>: {
        <span class="hljs-attr">"ecmaVersion"</span>: <span class="hljs-number">6</span>,	//ecmaScript的版本
        <span class="hljs-attr">"sourceType"</span>: <span class="hljs-string">"module"</span>,	//源码类型，<span class="hljs-attr">"script"</span>(默认)或者<span class="hljs-attr">"module"</span>，
        <span class="hljs-attr">"ecmaFeatures"</span>: {	//额外的语言特性
            <span class="hljs-attr">"globalReturn"</span>: <span class="hljs-literal">true</span>,	// 允许在全局作用域下使用 return 语句
            <span class="hljs-attr">"jsx"</span>: <span class="hljs-literal">true</span>,	//启用jsx
            <span class="hljs-attr">"impliedStrict"</span>: <span class="hljs-literal">true</span>	//启用全局 strict mode (如果 ecmaVersion 是 <span class="hljs-number">5</span> 或更高)
        },
    },
    
    //继承配置，可以是一个字符串或字符串数组，字符串内容可以是一个文件或者一个已安装的npm包
    <span class="hljs-attr">"extends"</span>: <span class="hljs-string">"airbnb-base"</span>,
    
    //配置启用环境
    <span class="hljs-attr">"env"</span>: {
        <span class="hljs-attr">"browser"</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">"node"</span>: <span class="hljs-literal">true</span>
        //还以其他的等等。。。
    },
    
    //全局变量名配置
    <span class="hljs-attr">"globals"</span>: {
        <span class="hljs-attr">"var1"</span>: <span class="hljs-literal">true</span>,	//在某个文件中访问var1不会报错了
    	<span class="hljs-attr">"var2"</span>: <span class="hljs-literal">true</span>	//在某个文件中访问var2会报错，即使全局环境中存在var2这个变量
    },
	
	//使用第三方插件
    //全局安装的 ESLint 只能使用全局安装的插件。
    //本地安装的 ESLint 不仅可以使用本地安装的插件还可以使用全局安装的插件。
    <span class="hljs-attr">"plugins"</span>: [
        <span class="hljs-string">"html"</span>
    ],
    
    //配置规则，http://eslint.cn/docs/rules/
    //<span class="hljs-string">"off"</span> 或 <span class="hljs-number">0</span> - 关闭规则
    //<span class="hljs-string">"warn"</span> 或 <span class="hljs-number">1</span> - 开启规则，使用警告级别的错误：warn (不会导致程序退出)
    //<span class="hljs-string">"error"</span> 或 <span class="hljs-number">2</span> - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)
    <span class="hljs-string">"rules"</span>: {
        <span class="hljs-attr">"indent"</span>: [
            <span class="hljs-string">"error"</span>,	//第一个为级别
            <span class="hljs-number">4</span>			//其他的为该规则的参数
        ],
        <span class="hljs-attr">"semi"</span>: <span class="hljs-number">0</span>,		//级别
        <span class="hljs-attr">"comma-dangle"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">"linebreak-style"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">"no-console"</span>: <span class="hljs-number">0</span>
    }
}
</code></pre>
</li>
<li>
<p>优先级</p>
<p>文件内注释 &gt; 配置文件，当前目录的配置文件  &gt;  父级目录的配置文件</p>
</li>
<li>
<p>忽视解析的文件或目录，用 .eslintignore 文件进行配置</p>
</li>
</ul>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/Eslint相关.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/读书笔记/webstorm.html">webstorm</a></h3>
        <div class="preview md_html">
            <h2 id="%E5%BF%AB%E6%8D%B7%E9%94%AE">快捷键</h2>
<ol>
<li>ctrl + shift + n: 打开工程中的文件，目的是打开当前工程下任意目录的文件。</li>
<li>ctrl + j: 输出模板</li>
<li>ctrl + b: 跳到变量申明处</li>
<li>ctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap withAbbreviation)</li>
<li>ctrl + []: 匹配 {}[]</li>
<li>ctrl + F12: 可以显示当前文件的结构</li>
<li>ctrl + x: 剪切(删除)行，不选中，直接剪切整个行，如果选中部分内容则剪切选中的内容</li>
<li>alt + left/right:标签切换</li>
<li>ctrl + r: 替换</li>
<li>ctrl + shift + up: 行移动</li>
<li>shift + alt + up: 块移动(if(){},while(){}语句块的移动)</li>
<li>ctrl + d: 行复制</li>
<li>ctrl + shift + ]/[: 选中块代码</li>
<li>ctrl + / : 单行注释</li>
<li>ctrl + shift + / : 块注释</li>
<li>ctrl + shift + i : 显示当前CSS选择器或者JS函数的详细信息</li>
<li>ctrl + '-/+': 可以折叠项目中的任何代码块，它不是选中折叠，而是自动识别折叠。</li>
<li>ctrl + '.': 折叠选中的代码的代码。</li>
<li>shift + esc: 当前激活的任意小窗口最小化，也可以是alt+数字键，数字在小窗口有显示。</li>
<li>alt + '7': 显示当前的函数结构。</li>
<li>如果是*.html页面，则在文件名下的导航栏某DOM结构上右键，可以全选当前DOM结构。</li>
</ol>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/读书笔记/webstorm.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/读书笔记/vsCode使用.html">vsCode使用</a></h3>
        <div class="preview md_html">
            <hr />
<h2 id="style%3A-ocean">style: ocean</h2>
<h3 id="%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91">代码编辑</h3>
<h5 id="%E6%A0%BC%E5%BC%8F%E8%B0%83%E6%95%B4">格式调整</h5>
<ul>
<li>代码缩进：ctrl + [ , ctrl +  ]</li>
<li>代码折叠：ctrl + shift +[ , ctrl + shift + ]</li>
<li>格式化：ctrl + alt + f （自定义快捷键）</li>
<li>上下行交换：alt + up 或 alt + down</li>
<li>向下(上)复制一行：shift + alt + up 或 shift + alt + down</li>
<li>向下插入一行：ctrl + enter</li>
<li>向上插入一行：ctrl + shift + enter</li>
<li>代码美化：ctrl + alt + b （自定义，美化插件beautify，可自定义配置）</li>
<li>复制或裁剪一行：不选中，ctrl+c , ctrl + x</li>
</ul>
<h5 id="%E5%85%89%E6%A0%87">光标</h5>
<ul>
<li>移动到行首或行末：home , end</li>
<li>移动到文件结尾或开头：ctrl + end， ctrl + home</li>
<li>向下选择行：ctrl + i</li>
<li>选择光标到行末位置：shift + end</li>
<li>选择光标到行首位置： shift + home</li>
<li>光标跳到上次的位置：ctrl + u</li>
<li>多光标：ctrl + alt + up/down</li>
<li>同时选中所有匹配的：Ctrl+Shift+L （再也不同ctrl + F/H 了）</li>
<li>以光标处为起点向上下左右选择文本：ctrl + shift + 上/下/左/右</li>
</ul>
<h5 id="%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84">代码重构</h5>
<ul>
<li>跳转到定义处：选中 -&gt; F12</li>
<li>定义处缩略图：只看一眼而不跳转过去Alt+F12</li>
<li>列出所有的引用：Shift+F12 (强)</li>
<li>修改变量名：选中变量名 -&gt; F12 -&gt; 修改 （强）</li>
</ul>
<h5 id="%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2">查找替换</h5>
<ul>
<li>查找：ctrl + f</li>
<li>查找替换：ctrl + h</li>
<li>整个文件夹查找：ctrl + shift + f</li>
</ul>
<h5 id="%E6%98%BE%E7%A4%BA%E7%9B%B8%E5%85%B3">显示相关</h5>
<ul>
<li>全屏：F11</li>
<li>zoomIn/zoomOut：Ctrl + =/Ctrl + -</li>
<li>侧边栏显/隐：Ctrl+B</li>
<li>预览markdown Ctrl+Shift+V</li>
</ul>
<h3 id="%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8E%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86">编辑器与窗口管理</h3>
<ul>
<li>打开/关闭一个新的窗口：ctrl + shift + n/w</li>
<li>新建一个文件：ctrl + n</li>
<li>关闭当前打开的一个文件：ctrl + w</li>
<li>在打开的文件中切换：ctrl + tab</li>
<li>新建编辑器视口并切换：ctrl + 1/2/3</li>
</ul>
<h3 id="%E6%8F%92%E4%BB%B6">插件</h3>
<h5 id="%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91-2">代码编辑</h5>
<ul>
<li>自动修改闭合标签：Auto Rename Tag</li>
<li>代码美化：Beautify</li>
<li>代码检验：ESLint</li>
<li>npm包导入提醒：node.js Modules Intellisense</li>
<li>路径智能提示：Path Intellisense</li>
</ul>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/读书笔记/vsCode使用.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/mobx.html">mobx</a></h3>
        <div class="preview md_html">
            <h4 id="autorun">Autorun</h4>
<p>参数：一个使用了observable数据的函数</p>
<p>返回：disposer函数，调用该函数可以去取消autorun，以及取消对computed值的计算</p>
<p>错误处理：可以用disposer.onError方法来覆盖Reaction的默认日志行为。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> age = observable(<span class="hljs-number">10</span>)
<span class="hljs-keyword">const</span> dispose = autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (age.get() &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Age should not be negative"</span>)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Age"</span>, age.get())
})
age.set(<span class="hljs-number">18</span>)  <span class="hljs-comment">// 输出: Age 18</span>
age.set(<span class="hljs-number">-10</span>) <span class="hljs-comment">// 输出: Age should not be negative</span>
age.set(<span class="hljs-number">5</span>)   <span class="hljs-comment">// 已恢复; 输出: Age 5</span>

dispose.onError(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">"Please enter a valid age"</span>)
})

age.set(<span class="hljs-number">-5</span>)  <span class="hljs-comment">// 显示alert弹出框</span>
</code></pre>
<p>全局的onError方法：全局的 onError 处理方法可以通过 extras.onReactionError(handler)来设置。</p>
<h4 id="%40observer">@observer</h4>
<p>将React组件转变成响应式组件。它用mobx.autorun 包装了组件的render函数以确保任何组件渲染中使用的数据变化是都可以强制刷新组件。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">"mobx-react"</span>;

<span class="hljs-keyword">var</span> timerData = observable({
    <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>
});

setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    timerData.secondsPassed++;
}, <span class="hljs-number">1000</span>);

@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: { this.props.timerData.secondsPassed } <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span> )
    }
};
<span class="hljs-comment">//secondsPassed改变会触发组件刷新</span>
React.render(&lt;Timer timerData={timerData} /&gt;, document.body);
/*secondsPassed改变不会触发组件刷新，因为此处只是单纯地传递了字面值而已，Timer无法获取到timerData.secondsPassed的变化*/
React.render(&lt;Timer timerData={timerData.secondsPassed} /&gt;, document.body); 
</code></pre>
<p>@observer、autorun函数所能观察的目标只能是引用，为了触发 **autorun **值需要通过引用来传递而不是字面值来传递。</p>
<ol>
<li>
<p>无状态函数组件</p>
<pre><code class="hljs language-react">import {observer} from &quot;mobx-react&quot;;

const Timer = observer(({ timerData }) =&gt;
    &lt;span&gt;Seconds passed: { timerData.secondsPassed } &lt;/span&gt;
);
</code></pre>
</li>
<li>
<p>可观察的局部组件状态</p>
<pre><code class="hljs language-react">import {observer} from &quot;mobx-react&quot;
import {observable} from &quot;mobx&quot;

@observer class Timer extends React.Component {
    @observable secondsPassed = 0

    componentWillMount() {
        setInterval(() =&gt; {
            this.secondsPassed++
        }, 1000)
    }

    render() {
        return (&lt;span&gt;Seconds passed: { this.secondsPassed } &lt;/span&gt; )
    }
})

React.render(&lt;Timer /&gt;, document.body)
</code></pre>
<p>mobx局部组件状态的变化只会触发render、componentWillUpdate、componentDidUpdate</p>
</li>
<li>
<p>componentWillReact 生命周期钩子</p>
<p>当使用 mobx-react 时可以定义一个新的生命周期钩子函数 componentWillReact(一语双关)。当组件因为它观察的数据发生了改变，它会安排重新渲染，这个时候 componentWillReact 会被触发。</p>
<h4 id="action">action</h4>
<p>应该永远只对<strong>修改</strong>状态的函数使用动作</p>
<ul>
<li>
<p>绑定的动作</p>
<pre><code class="hljs language-react">class Ticker {
    @observable tick = 0

    @action.bound
    increment() {
        this.tick++ // 'this' 永远都是正确的
    }
}
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="mobx%E4%BC%9A%E5%AF%B9%E4%BB%80%E4%B9%88%E5%81%9A%E5%87%BA%E5%8F%8D%E5%BA%94%EF%BC%9F">Mobx会对什么做出反应？</h4>
<blockquote>
<p>Mobx 会对在<strong>追踪函数</strong>执行过程中<strong>读取</strong>现存的可观察属性做出反应。</p>
</blockquote>
<p>调用过至少一次getter(注册观察者)，使用setter(执行过程)</p>
<p>Mobx的observable函数就是通过普通对象生产一个拥有getter、setter属性的对象，其中getter的首次调用用于初始化初值并注册该属性的观察者，</p>
<p>单例模式、观察者模式、</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/mobx.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/读书笔记/ssh.html">ssh</a></h3>
        <div class="preview md_html">
            <h4 id="%E7%BB%91%E5%AE%9A%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3">绑定本地端口</h4>
<pre><code class="hljs language-bash">ssh -D 8080 user@host
</code></pre>
<p>ssh建立一个socket，监听本地的8080端口，就自动把它转移到SSH连接上面，发往远程主机。</p>
<h4 id="%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">本地端口转发</h4>
<pre><code class="hljs language-bash">ssh -L localPort: remoteHost :remotePort SSHHost
</code></pre>
<p>ssh链接由**执行方(本地)<strong>向</strong>SSHHost(远程)**发起，ssh监听本地端口localPort，将localPort数据转发给了SSHHost的sshServer，sshServer将数据转发给远程服务端口remoteHost:remotePort,远程服务器返回的数据将原路返回到本地端口。</p>
<h4 id="%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">远程端口转发</h4>
<pre><code class="hljs language-bash">ssh -R localPort: remoteHost :remotePort SSHHost
</code></pre>
<p>ssh链接由**执行方(远程)<strong>向</strong>SSHHost(本地)<strong>发起，<strong>执行方ssh</strong>要求</strong>SSHHost(本地)**上的sshServer监听localPort端口并将localPort端口数据返回给自己，由自己将数据转发给远程服务端口remoteHost:remotePort，远程服务器返回的数据将原路返回到本地端口。</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/读书笔记/ssh.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/读书笔记/git.html">git</a></h3>
        <div class="preview md_html">
            <h3 id="fetch">fetch</h3>
<h4 id="%E6%8F%8F%E8%BF%B0">描述</h4>
<p>拉去远程分支，默认再本地增加origin/XXX分支</p>
<h4 id="%E5%8F%82%E6%95%B0">参数</h4>
<p>--prune / -p ：fetch之前删除本地中对远程分支的引用，如果改引用再远程分支中已经不存在</p>
<h3 id="commit">commit</h3>
<p>git commit --amend 修补提交</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/读书笔记/git.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/redux之基础概念.html">redux之基础概念</a></h3>
        <div class="preview md_html">
            <h3 id="%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5">一、概念</h3>
<blockquote>
<p>应用中所有的 state 都以一个对象树的形式储存在一个单一的 <em>store</em> 中。 惟一改变 state 的办法是触发 <em>action</em>，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 <em>reducers</em>。</p>
</blockquote>
<ul>
<li>reducer ：一个形式为 (state,action) =&gt; state 的纯函数。
<ul>
<li>定义了状态的更新规则，即每个action如何改变应用的 state</li>
</ul>
</li>
<li>state ：记录应用的状态，可以包含各种业务数据，也可以包含各个组件共享数据</li>
<li>store：可以理解为应用状态的管理者。</li>
<li>action：描述一个动作的对象，type属性是必须其他结构任意。</li>
<li>actionCreator：一个返回action对象的函数</li>
</ul>
<h3 id="%E4%BA%8C%E3%80%81%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99">二、三大原则</h3>
<ul>
<li>单一数据源</li>
<li>state是只读的</li>
<li>使用纯函数来执行修改</li>
</ul>
<h3 id="%E4%B8%89%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84-demos">三、简单的 demos</h3>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 定义actions</span>
<span class="hljs-keyword">const</span> INCREASE = {<span class="hljs-attr">type</span>: <span class="hljs-string">'increase'</span>,  <span class="hljs-attr">addend</span>: <span class="hljs-number">1</span>};
<span class="hljs-keyword">const</span> MINUS = {<span class="hljs-attr">type</span>: <span class="hljs-string">'minus'</span>, <span class="hljs-attr">subtrahend</span>: <span class="hljs-number">1</span>};

<span class="hljs-comment">// 定义actionCreate </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increase</span>(<span class="hljs-params">addend</span>) </span>{
    <span class="hljs-keyword">return</span> {...INCREASE, addend}
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minus</span>(<span class="hljs-params">subtrahend</span>) </span>{
    <span class="hljs-keyword">return</span> {...MINUS, subtrahend}
}

<span class="hljs-comment">//定义初始化的state结构</span>
<span class="hljs-keyword">const</span> initState = {
    <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>
}

<span class="hljs-comment">// 定义reducer</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state = initState, action</span>) </span>{
    <span class="hljs-keyword">switch</span>(action.type) {
        <span class="hljs-keyword">case</span> INCREASE.type: <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {<span class="hljs-attr">num</span>: state.num + action.addend});
        <span class="hljs-keyword">case</span> MINUS.type: <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {<span class="hljs-attr">num</span>: state.num - action.subtrahend});
    }
}

<span class="hljs-comment">// 创建store</span>
<span class="hljs-keyword">const</span> store = createStore(reducer, initState)

<span class="hljs-comment">// 监听变化</span>
store.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(store.getState())
})

<span class="hljs-comment">// 触发action</span>
store.dispatch(increase(<span class="hljs-number">3</span>)) <span class="hljs-comment">// log: {num: 3}</span>
store.dispatch(minus(<span class="hljs-number">2</span>)) <span class="hljs-comment">// log: {num: 1}</span>
</code></pre>
<h3 id="%E5%9B%9B%E3%80%81%E5%AF%B9api%E7%9A%84%E7%90%86%E8%A7%A3">四、对API的理解</h3>
<h4 id="1.-createstore">1. <strong>createStore</strong></h4>
<p><code>createStore(reducer, [initState], enhancer)</code></p>
<ul>
<li>enhancer：(createStore) =&gt;  (reducer, [initState]) =&gt; store</li>
</ul>
<h4 id="2.-store">2. <strong>Store</strong></h4>
<ol>
<li>获取state：<code>getState()</code>方法获取state</li>
<li>更新state：<code>dispatch(action)</code>方法更新state，也是唯一的改变state的方法</li>
<li>订阅state：<code>subscribe(listener)</code>注册监听器，每一个次状态的变化都会触发listener函数</li>
<li>注销监听：通过 <code>subscribe(listener)</code>返回的函数注销监听器。</li>
<li>更新替换reducer: <code>replaceReducer(nextReducer)</code></li>
</ol>
<h4 id="3.-combinereducers(reducers)">3. <strong>combineReducers</strong>(reducers)</h4>
<p>返回值:</p>
<blockquote>
<p>(<em>Function</em>)：一个调用 <code>reducers</code>对象里所有 reducer 的 reducer，并且构造一个与 <code>reducers</code>对象结构相同的 state 对象。</p>
</blockquote>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// combineReducers做了什么？</span>
<span class="hljs-comment">// 1. 对每个reducer做校验</span>
<span class="hljs-comment">// 2. 存储reducersMap</span>
<span class="hljs-comment">// 3. 返回一个新的reducer函数，该函数拥有reducersMap的访问权</span>
<span class="hljs-comment">// dispatch时rootReducer做了什么？</span>
<span class="hljs-comment">// 1. 依次执行每个reducer函数，参数action不变，但参数state只是整的state的一部分，</span>
<span class="hljs-comment">// 2. 将reducer函数放回的数据(部分的state)，更新到整体的state树上</span>
<span class="hljs-comment">// 3. 返回新的整体的state</span>

<span class="hljs-comment">// 部分源码</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineReducers</span>(<span class="hljs-params">reducers</span>) </span>{
  <span class="hljs-keyword">const</span> reducerKeys = <span class="hljs-built_in">Object</span>.keys(reducers)
  <span class="hljs-comment">// 存储finalReducers， finalReducerKeys</span>
  <span class="hljs-keyword">const</span> finalReducers = {}
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; reducerKeys.length; i++) {
    <span class="hljs-keyword">const</span> key = reducerKeys[i]

    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reducers[key] === <span class="hljs-string">'undefined'</span>) {
        warning(<span class="hljs-string">`No reducer provided for key "<span class="hljs-subst">${key}</span>"`</span>)
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reducers[key] === <span class="hljs-string">'function'</span>) {
      finalReducers[key] = reducers[key]
    }
  }
  <span class="hljs-keyword">const</span> finalReducerKeys = <span class="hljs-built_in">Object</span>.keys(finalReducers)
  <span class="hljs-comment">/** 校验部分 */</span>
  
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combination</span>(<span class="hljs-params">state = {}, action</span>) </span>{
	<span class="hljs-comment">/** 校验部分 */</span>
    <span class="hljs-keyword">let</span> hasChanged = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">const</span> nextState = {}
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; finalReducerKeys.length; i++) {
      <span class="hljs-keyword">const</span> key = finalReducerKeys[i]
      <span class="hljs-keyword">const</span> reducer = finalReducers[key]
      <span class="hljs-keyword">const</span> previousStateForKey = state[key]
      <span class="hljs-keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextStateForKey === <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    <span class="hljs-keyword">return</span> hasChanged ? nextState : state
  }
}
<span class="hljs-comment">// combineReducers原理上是可以无限嵌套的，如下</span>
<span class="hljs-comment">// combineReducers(rd: combineReducers({..}), ed: combineReducers({...}))</span>
</code></pre>
<h4 id="4.-applymiddleware">4. <strong>applyMiddleware</strong></h4>
<p><code>applyMiddleware(...middlewares)</code>其实就是一个生成storeEnhancer的函数，该enhancer用来增强store的(增强的dispatch方法)</p>
<ol>
<li>参数: <code>middleware: ({ getState, dispatch }) =&gt; next =&gt; action</code></li>
<li>返回值:  createStore  =&gt;  createStore。</li>
</ol>
<h4 id="5.-bindactioncreators">5. bindActionCreators</h4>
<p><code>bindActionCreators(actionCreators, dispatch)</code> 对<code>actionCreators</code>中的每个<code>actionCreator</code>使用dispatch进行包装<code>(...p) =&gt; dispatch(actionCreator(...p))</code>,  并返回原有的结构</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ......</span>
<span class="hljs-keyword">const</span> createFooAction = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({<span class="hljs-attr">type</span>: <span class="hljs-string">'foo'</span>});
<span class="hljs-keyword">const</span> createBarAction = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({<span class="hljs-attr">type</span>: <span class="hljs-string">'bar'</span>});
<span class="hljs-keyword">const</span> bondDispatchActions = bindActionCreators({
    <span class="hljs-attr">foo</span>: createFooAction,
    <span class="hljs-attr">bar</span>: createBarAction
}, dispatch)
<span class="hljs-comment">// bondDispatchActions等价如下</span>
{
    <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch(createFooAction()),
    <span class="hljs-attr">bar</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispathc(createBarAction())
}
</code></pre>
<h4 id="6.-compose">6. compose</h4>
<p>从右到左来组合多个函数。</p>
<pre><code class="hljs language-javascript">compose(funcA, funcB, funcC)
<span class="hljs-comment">// 等价如下</span>
compose(funcA(funcB(funcC())))）
</code></pre>
<h3 id="%E4%BA%94%E3%80%81%E5%BC%82%E6%AD%A5action">五、异步action</h3>
<ul>
<li>将原本一个动作分解为多个，比如一个网络请求动作可分为 发起请求，获取中，得到结果(成功或失败)。</li>
<li>给同一个传入不同的<code>payload</code>(type之外的字段)，并根据不同的<code>payload</code>返回不同的state</li>
</ul>
<h3 id="%E5%85%AD%E3%80%81%E4%B8%80%E4%BA%9B%E6%9D%A5%E8%87%AA%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9A%84%E5%BB%BA%E8%AE%AE">六、一些来自官方文档的建议</h3>
<h4 id="1.%E5%B0%86%E6%80%8E%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E6%94%BE%E5%85%A5-redux%3F">1.将怎样的数据放入 Redux?</h4>
<blockquote>
<ul>
<li>应用的其他部分是否关心这个数据？</li>
<li>是否需要根据需要在原始数据的基础上创建衍生数据？</li>
<li>相同的数据是否被用作驱动多个组件？</li>
<li>能否将状态恢复到特定时间点（在时光旅行调试的时候）？</li>
<li>是否要缓存数据（比如：数据存在的情况下直接去使用它而不是重复去请求他）？</li>
</ul>
</blockquote>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/redux之基础概念.html">Read</a>
            </div>
        </div>
    </section>
    
    <section class="article_item">
        <h3><a href="/前端开发/typeScript.html">typeScript</a></h3>
        <div class="preview md_html">
            <h3 id="%E7%B1%BB%E5%9E%8B">类型</h3>
<ol>
<li>
<p>类型声明，冒号+类型  -&gt; :boolean | :number | :string</p>
</li>
<li>
<p>类型种类：布尔值(boolean)、 数字(number) 、字符串(string)、数组(Array|Array<number>)、元组(Tuple)、枚举(enum)、任意类型(Any)、void(函数无返回值、只能赋值为null和undefined)、Null 、Undefined、never</p>
</li>
<li>
<p>元组：一个固定长度、元素类型固定的数组：let x: [string, number]</p>
</li>
<li>
<p>枚举：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Color {Red, Green, Blue}	<span class="hljs-comment">//Color.Red 等于0</span>
<span class="hljs-keyword">let</span> c: Color = Color.Green		
<span class="hljs-comment">//c被定义为Color枚举类型，只能在被赋值为{Red, Green, Blue}中的一个，实际对应的是{0，1，2}</span>
<span class="hljs-keyword">enum</span> Color {Red=<span class="hljs-number">1</span>, Green=<span class="hljs-number">2</span>, Blue}	<span class="hljs-comment">//可以修改默认值</span>
<span class="hljs-keyword">let</span> c: Color = Color.Green	
</code></pre>
</li>
<li>
<p>类型断言?</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> someValue: <span class="hljs-built_in">any</span> = <span class="hljs-string">"hello !"</span>
<span class="hljs-keyword">let</span> strLength: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).length;
</code></pre>
</li>
</ol>
<h3 id="%E5%8F%98%E9%87%8F">变量</h3>
<ol>
<li>
<p>let与const，与es6相同</p>
</li>
<li>
<p>解构</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*数组解构*/</span>
<span class="hljs-keyword">let</span> input = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
<span class="hljs-keyword">let</span> [first,second] = input <span class="hljs-comment">//声明了两个变量</span>
[first,second] = [second,first] <span class="hljs-comment">//变量交换</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">[p1,p2]</span>)</span>{<span class="hljs-comment">/*...*/</span>}	<span class="hljs-comment">//传入一个数组，在函数内部生成两个变量，p1、p2</span>
<span class="hljs-keyword">let</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];	<span class="hljs-comment">//剩余变量，rest 相当于[2,3,4]</span>
</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*对象解构*/</span>
<span class="hljs-keyword">let</span> o = {a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>};
<span class="hljs-keyword">let</span> {a,b} = o;
<span class="hljs-keyword">let</span> {a = <span class="hljs-number">100</span>, b} = o;	<span class="hljs-comment">//默认值</span>
<span class="hljs-keyword">let</span> {a,...r} = o; <span class="hljs-comment">//剩余变量，r = {b: 2，c: 3}</span>
<span class="hljs-keyword">let</span> { a: one, b: two } = o;	<span class="hljs-comment">//属性重命名</span>
<span class="hljs-keyword">let</span> { a: one, b: two }:{a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span>} = o;	<span class="hljs-comment">//设置类型</span>
<span class="hljs-comment">/*函数声明*/</span>
<span class="hljs-keyword">type</span> C = { a: <span class="hljs-built_in">string</span>, b?: <span class="hljs-built_in">number</span> }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">{ a, b }: C</span>): <span class="hljs-title">void</span> </span>{<span class="hljs-comment">/*.......*/</span>} 
<span class="hljs-comment">//传入一个C类型的对象，在函数内部生成a、b两个变量</span>
</code></pre>
</li>
<li>
<p>展开</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*数组展开*/</span>
<span class="hljs-keyword">let</span> ar = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, ...ar]
<span class="hljs-comment">/*对象展开*/</span>
<span class="hljs-keyword">let</span> o = {b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>}
<span class="hljs-keyword">let</span> oo = {a: <span class="hljs-number">1</span>, ...o}
<span class="hljs-comment">// 出现在展开对象后面的属性会覆盖前面的属性。</span>
<span class="hljs-comment">//对象展开仅包含对象自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法</span>
</code></pre>
</li>
</ol>
<h3 id="%E6%8E%A5%E5%8F%A3">接口</h3>
<ol>
<li>
<p>概念：typescript的接口像是一种对<strong>对象</strong>结构的描述，像是一种自定义类型，将一个变量声明为该接口类型时，此变量的值就必须满足接口的描述，否则将编译不过</p>
</li>
<li>
<p>可选属性，但一个接口定义的属性可有可无时，可以将其定义为可选类型，来避免编译报错</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*必选*/</span>
<span class="hljs-keyword">interface</span> SquareConfig {
  color: <span class="hljs-built_in">string</span>;
  width: <span class="hljs-built_in">number</span>;
}
<span class="hljs-comment">/*可选*/</span>
<span class="hljs-keyword">interface</span> SquareConfig {
  color?: <span class="hljs-built_in">string</span>;
  width?: <span class="hljs-built_in">number</span>;
}
</code></pre>
</li>
<li>
<p>只读属性：一些对象属性只能在对象刚刚创建的时候修改其值，其他时间是不允许修改的</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Point {
    readonly x: <span class="hljs-built_in">number</span>;	<span class="hljs-comment">//用readonly来定义只读属性</span>
    readonly y: <span class="hljs-built_in">number</span>;
}
<span class="hljs-comment">/*只读数组 ReadonlyArray&lt;T&gt;*/</span>
<span class="hljs-keyword">let</span> a: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">let</span> ro: ReadonlyArray&lt;<span class="hljs-built_in">number</span>&gt; = a;
ro[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>; <span class="hljs-comment">// error!</span>
ro.push(<span class="hljs-number">5</span>); <span class="hljs-comment">// error!</span>
ro.length = <span class="hljs-number">100</span>; <span class="hljs-comment">// error!</span>
a = ro; <span class="hljs-comment">// error!</span>
</code></pre>
<p>对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 <strong>如果一个对象字面量</strong>存在任何“<strong>目标类型</strong>”不包含的属性时，你会得到一个错误。</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*绕开检查*/</span>
<span class="hljs-keyword">let</span> mySquare = createSquare({ width: <span class="hljs-number">100</span>, opacity: <span class="hljs-number">0.5</span> } <span class="hljs-keyword">as</span> SquareConfig);
</code></pre>
</li>
<li>
<p>可索引的类型: 共支持两种索引签名<strong>字符串</strong> 、<strong>数字</strong></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> StringArray {
  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">let</span> myArray: StringArray = [<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Fred"</span>];
<span class="hljs-comment">/* 错误：使用'string'索引，有时会得到number!*/</span>
<span class="hljs-keyword">interface</span> NotOkay {	
    [x: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;	<span class="hljs-comment">//数字索引会转化为字符串索引，比如100或转化为"100"</span>
    [x: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> NumberDictionary {
  	[index: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;
  	length: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// 可以，length是number类型</span>
  	name: <span class="hljs-built_in">string</span>       <span class="hljs-comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span>
}
<span class="hljs-comment">/*只读*/</span>
<span class="hljs-keyword">interface</span> ReadonlyStringArray {
    readonly [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//防止给索引赋值</span>
}
</code></pre>
</li>
<li>
<p>函数类型</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> SearchFunc {
    (source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;	
	<span class="hljs-comment">//(参数1:参数1类型,参2数: 参数2类型): 返回类型</span>
}
<span class="hljs-keyword">let</span> mysearch: SearchFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s1:<span class="hljs-built_in">string</span>,s2:<span class="hljs-built_in">string</span></span>)</span>{
    <span class="hljs-comment">//balabala.....</span>
    <span class="hljs-comment">//函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre>
</li>
<li>
<p>继承接口，extends 接口1, 接口2</p>
</li>
<li>
<p>接口继承类：当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。</p>
<p><strong>接口继承类形成的接口，实现该接口的类必须且只能是 <u>被继承类</u> 的子类</strong></p>
</li>
</ol>
<h3 id="%E7%B1%BB">类</h3>
<h5 id="%E7%BB%A7%E6%89%BF">继承</h5>
<p>子类继承基类的public、protected属性和方法，</p>
<ol>
<li>在子类中可以通过this.xxx访问到xxx属性或方法，</li>
<li>子类的构造函数内必须首先执行基类的构造方法,通过执行super()</li>
<li>子类可以重写基类的方法，重写(xxx)后还是可以通过super.xxx() 访问到基类的方法。</li>
</ol>
<h5 id="%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9">类型兼容</h5>
<ol>
<li>两个类都没有public、protected的属性和方法，而且具有相同的公有属性和方法，那这两个类是兼容的，</li>
<li>两个类都继承自一个基类并且有与上述一样的情况，那这两个类是兼容的</li>
<li>兼容的类的实例值可互换。</li>
</ol>
<h5 id="%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">访问控制</h5>
<ol>
<li>private ：不能在类外部使用，也不能在子类直接使用，子类只能通过基类的public、和protected方法间接访问，类的外部只能通过类实例的方法来间接访问私有的属性或方法</li>
<li>protected：不能在类外部使用，能继承给子类，子类可直接通过this.xxx访问的到protected的方法或属性</li>
<li>public：默认</li>
</ol>
<h5 id="%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7">只读属性</h5>
<p>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<h5 id="%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7">参数属性</h5>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>) { } <span class="hljs-comment">//自动赋值了</span>
    move(distanceInMeters: <span class="hljs-built_in">number</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${this.name}</span> moved <span class="hljs-subst">${distanceInMeters}</span>m.`</span>);
    }
}
</code></pre>
<h5 id="%E5%AD%98%E5%8F%96%E5%99%A8">存取器</h5>
<ol>
<li>get name(){}</li>
<li>set name(str){}</li>
</ol>
<h5 id="%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7">静态属性</h5>
<p>用static修饰属性，该属性是属于类的，实在类建立时初始化的，而不是创建实例时，可以同过 <strong>类名.xxx</strong> 直接访问，所有的子类可共享该属性。</p>

        </div>
        <div class="article_item_footer">
            <div class="read_btn">
                <a href="/前端开发/typeScript.html">Read</a>
            </div>
        </div>
    </section>
    
    <div class="page_box">
    <div class="page_pre">
        <a class="page_pre_item" class="" href="/articles/1.html">FIRST</a>
        <a class="page_pre_item" href="/articles/52.html">
            <i class="iconfont icon-previous"></i>
        </a>
    </div>
    <div class="page_num">
        
    </div>
    <div class="page_next">
        <a class="page_next_item" href="/articles/54.html">
            <i class="iconfont icon-next"></i>
        </a>
        <a class="page_next_item" href="/articles/57.html">LAST</a>
    </div>
    </div>
</div>
    </div>
    <aside>
        <div class="profile_banner"></div>
        <div class="profile_logo">
        <img src="/assets/logo.png" alt="">
        </div>
        <div class="profile_name">
            qoxop
        </div>
        <div class="profile_motto">
            一只单身的帅狗, 打代码、打游戏、撸猫、无恶不做~~~
        </div>
        <div class="profile_info">
        <div>
            <div class="iconbox"><em class="iconfont icon-github"></em></div>
            <div class="icontext">github</div>
        </div>
        <div>
            <div class="iconbox"><em class="iconfont icon-resume"></em></div>
            <div class="icontext">resume</div>
        </div>
        <div>...</div>
        </div>
    </aside>
</div>
        </main>
        <footer id="footer"></footer>
      </article>
      <div class="shortcut-tools">
          <div onclick="exec('scrollToTop')" class="goto-top-btn">Top</div>
          <div onclick="exec('scrollToBottom')" class="goto-bottom-btn">Bottom</div>
          <div onclick="exec('goback')" class="goback-btn">goback</div>
      </div>
      <script src="/assets/common.js"></script>
</body>
</html>