<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="author" content="qoxop">
    <meta name="keywords" content="">
    <meta name="description" content="类型声明，冒号+类型  -&amp;gt; :boolean | :number | :string">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="bookmark" href="/favicon.ico">
    <link rel="stylesheet" href="/assets/style/index.css">
    <title>typeScript</title>
<link rel="stylesheet" href="/assets/code_styles/solarized-light.css"></head>
<body>
    <header>
        <div class="header">
            <h1><a class="unset" href="/">阿伟的网络日志</a></h1>
            <nav>
                <ul>
                    <li>
                        <a class="unset" href="/index.html">Home</a>
                    </li>
                    <li>
                        <a class="unset" href="/tags.html">Tags</a>
                    </li>
                    <li>
                        <a class="unset" href="/about.html">About</a>
                    </li>
                </ul>
            </nav>
        </div>
    </header>
    <main>
        <article id="article_main"><h1>typeScript</h1><section class="article_info">
        <span class="author">author: qoxop</span>
        <span class="update_time">update at: 2018-12-22</span>
    </section><div class="from_markdown"><h3 id="%E7%B1%BB%E5%9E%8B">类型</h3>
<ol>
<li>
<p>类型声明，冒号+类型  -&gt; :boolean | :number | :string</p>
</li>
<li>
<p>类型种类：布尔值(boolean)、 数字(number) 、字符串(string)、数组(Array|Array<number>)、元组(Tuple)、枚举(enum)、任意类型(Any)、void(函数无返回值、只能赋值为null和undefined)、Null 、Undefined、never</number></p>
</li>
<li>
<p>元组：一个固定长度、元素类型固定的数组：let x: [string, number]</p>
</li>
<li>
<p>枚举：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Color {Red, Green, Blue}	<span class="hljs-comment">//Color.Red 等于0</span>
<span class="hljs-keyword">let</span> c: Color = Color.Green		
<span class="hljs-comment">//c被定义为Color枚举类型，只能在被赋值为{Red, Green, Blue}中的一个，实际对应的是{0，1，2}</span>
<span class="hljs-keyword">enum</span> Color {Red=<span class="hljs-number">1</span>, Green=<span class="hljs-number">2</span>, Blue}	<span class="hljs-comment">//可以修改默认值</span>
<span class="hljs-keyword">let</span> c: Color = Color.Green	
</code></pre>
</li>
<li>
<p>类型断言?</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> someValue: <span class="hljs-built_in">any</span> = <span class="hljs-string">"hello !"</span>
<span class="hljs-keyword">let</span> strLength: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).length;
</code></pre>
</li>
</ol>
<h3 id="%E5%8F%98%E9%87%8F">变量</h3>
<ol>
<li>
<p>let与const，与es6相同</p>
</li>
<li>
<p>解构</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*数组解构*/</span>
<span class="hljs-keyword">let</span> input = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
<span class="hljs-keyword">let</span> [first,second] = input <span class="hljs-comment">//声明了两个变量</span>
[first,second] = [second,first] <span class="hljs-comment">//变量交换</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">[p1,p2]</span>)</span>{<span class="hljs-comment">/*...*/</span>}	<span class="hljs-comment">//传入一个数组，在函数内部生成两个变量，p1、p2</span>
<span class="hljs-keyword">let</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];	<span class="hljs-comment">//剩余变量，rest 相当于[2,3,4]</span>
</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*对象解构*/</span>
<span class="hljs-keyword">let</span> o = {a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>};
<span class="hljs-keyword">let</span> {a,b} = o;
<span class="hljs-keyword">let</span> {a = <span class="hljs-number">100</span>, b} = o;	<span class="hljs-comment">//默认值</span>
<span class="hljs-keyword">let</span> {a,...r} = o; <span class="hljs-comment">//剩余变量，r = {b: 2，c: 3}</span>
<span class="hljs-keyword">let</span> { a: one, b: two } = o;	<span class="hljs-comment">//属性重命名</span>
<span class="hljs-keyword">let</span> { a: one, b: two }:{a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span>} = o;	<span class="hljs-comment">//设置类型</span>
<span class="hljs-comment">/*函数声明*/</span>
<span class="hljs-keyword">type</span> C = { a: <span class="hljs-built_in">string</span>, b?: <span class="hljs-built_in">number</span> }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">{ a, b }: C</span>): <span class="hljs-title">void</span> </span>{<span class="hljs-comment">/*.......*/</span>} 
<span class="hljs-comment">//传入一个C类型的对象，在函数内部生成a、b两个变量</span>
</code></pre>
</li>
<li>
<p>展开</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*数组展开*/</span>
<span class="hljs-keyword">let</span> ar = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, ...ar]
<span class="hljs-comment">/*对象展开*/</span>
<span class="hljs-keyword">let</span> o = {b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>}
<span class="hljs-keyword">let</span> oo = {a: <span class="hljs-number">1</span>, ...o}
<span class="hljs-comment">// 出现在展开对象后面的属性会覆盖前面的属性。</span>
<span class="hljs-comment">//对象展开仅包含对象自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法</span>
</code></pre>
</li>
</ol>
<h3 id="%E6%8E%A5%E5%8F%A3">接口</h3>
<ol>
<li>
<p>概念：typescript的接口像是一种对<strong>对象</strong>结构的描述，像是一种自定义类型，将一个变量声明为该接口类型时，此变量的值就必须满足接口的描述，否则将编译不过</p>
</li>
<li>
<p>可选属性，但一个接口定义的属性可有可无时，可以将其定义为可选类型，来避免编译报错</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*必选*/</span>
<span class="hljs-keyword">interface</span> SquareConfig {
  color: <span class="hljs-built_in">string</span>;
  width: <span class="hljs-built_in">number</span>;
}
<span class="hljs-comment">/*可选*/</span>
<span class="hljs-keyword">interface</span> SquareConfig {
  color?: <span class="hljs-built_in">string</span>;
  width?: <span class="hljs-built_in">number</span>;
}
</code></pre>
</li>
<li>
<p>只读属性：一些对象属性只能在对象刚刚创建的时候修改其值，其他时间是不允许修改的</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Point {
    readonly x: <span class="hljs-built_in">number</span>;	<span class="hljs-comment">//用readonly来定义只读属性</span>
    readonly y: <span class="hljs-built_in">number</span>;
}
<span class="hljs-comment">/*只读数组 ReadonlyArray&lt;T&gt;*/</span>
<span class="hljs-keyword">let</span> a: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">let</span> ro: ReadonlyArray&lt;<span class="hljs-built_in">number</span>&gt; = a;
ro[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>; <span class="hljs-comment">// error!</span>
ro.push(<span class="hljs-number">5</span>); <span class="hljs-comment">// error!</span>
ro.length = <span class="hljs-number">100</span>; <span class="hljs-comment">// error!</span>
a = ro; <span class="hljs-comment">// error!</span>
</code></pre>
<p>对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 <strong>如果一个对象字面量</strong>存在任何“<strong>目标类型</strong>”不包含的属性时，你会得到一个错误。</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/*绕开检查*/</span>
<span class="hljs-keyword">let</span> mySquare = createSquare({ width: <span class="hljs-number">100</span>, opacity: <span class="hljs-number">0.5</span> } <span class="hljs-keyword">as</span> SquareConfig);
</code></pre>
</li>
<li>
<p>可索引的类型: 共支持两种索引签名<strong>字符串</strong> 、<strong>数字</strong></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> StringArray {
  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">let</span> myArray: StringArray = [<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Fred"</span>];
<span class="hljs-comment">/* 错误：使用'string'索引，有时会得到number!*/</span>
<span class="hljs-keyword">interface</span> NotOkay {	
    [x: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;	<span class="hljs-comment">//数字索引会转化为字符串索引，比如100或转化为"100"</span>
    [x: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> NumberDictionary {
  	[index: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;
  	length: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// 可以，length是number类型</span>
  	name: <span class="hljs-built_in">string</span>       <span class="hljs-comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span>
}
<span class="hljs-comment">/*只读*/</span>
<span class="hljs-keyword">interface</span> ReadonlyStringArray {
    readonly [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//防止给索引赋值</span>
}
</code></pre>
</li>
<li>
<p>函数类型</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> SearchFunc {
    (source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;	
	<span class="hljs-comment">//(参数1:参数1类型,参2数: 参数2类型): 返回类型</span>
}
<span class="hljs-keyword">let</span> mysearch: SearchFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s1:<span class="hljs-built_in">string</span>,s2:<span class="hljs-built_in">string</span></span>)</span>{
    <span class="hljs-comment">//balabala.....</span>
    <span class="hljs-comment">//函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre>
</li>
<li>
<p>继承接口，extends 接口1, 接口2</p>
</li>
<li>
<p>接口继承类：当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。</p>
<p><strong>接口继承类形成的接口，实现该接口的类必须且只能是 <u>被继承类</u> 的子类</strong></p>
</li>
</ol>
<h3 id="%E7%B1%BB">类</h3>
<h5 id="%E7%BB%A7%E6%89%BF">继承</h5>
<p>子类继承基类的public、protected属性和方法，</p>
<ol>
<li>在子类中可以通过this.xxx访问到xxx属性或方法，</li>
<li>子类的构造函数内必须首先执行基类的构造方法,通过执行super()</li>
<li>子类可以重写基类的方法，重写(xxx)后还是可以通过super.xxx() 访问到基类的方法。</li>
</ol>
<h5 id="%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9">类型兼容</h5>
<ol>
<li>两个类都没有public、protected的属性和方法，而且具有相同的公有属性和方法，那这两个类是兼容的，</li>
<li>两个类都继承自一个基类并且有与上述一样的情况，那这两个类是兼容的</li>
<li>兼容的类的实例值可互换。</li>
</ol>
<h5 id="%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">访问控制</h5>
<ol>
<li>private ：不能在类外部使用，也不能在子类直接使用，子类只能通过基类的public、和protected方法间接访问，类的外部只能通过类实例的方法来间接访问私有的属性或方法</li>
<li>protected：不能在类外部使用，能继承给子类，子类可直接通过this.xxx访问的到protected的方法或属性</li>
<li>public：默认</li>
</ol>
<h5 id="%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7">只读属性</h5>
<p>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<h5 id="%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7">参数属性</h5>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>) { } <span class="hljs-comment">//自动赋值了</span>
    move(distanceInMeters: <span class="hljs-built_in">number</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${this.name}</span> moved <span class="hljs-subst">${distanceInMeters}</span>m.`</span>);
    }
}
</code></pre>
<h5 id="%E5%AD%98%E5%8F%96%E5%99%A8">存取器</h5>
<ol>
<li>get name(){}</li>
<li>set name(str){}</li>
</ol>
<h5 id="%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7">静态属性</h5>
<p>用static修饰属性，该属性是属于类的，实在类建立时初始化的，而不是创建实例时，可以同过 <strong>类名.xxx</strong> 直接访问，所有的子类可共享该属性。</p>
</div><section class="tags_bar"></section></article>
        <aside> 
            <section class="assist-tool">
                <div class="back-to-top">
                    <em class="iconfont icon-top"></em>
                </div>
            </section>
        </aside>
    </main>
    <footer>
        <div class="scrollTips" id="scrollTips">
        </div>
        <section class="copyright">
            copyright © 2019 by zhangjiwei
        </section>
        <section class="ICP_NUM">
            <a href="http://www.miitbeian.gov.cn">
                粤ICP备19026817号-1
            </a>
        </section>
    </footer>
    <script src="/assets/script/common.js"></script>


<script src="/assets/script/article.js"></script></body></html>