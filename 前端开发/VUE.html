<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="keywords" content="">
    <title>qoxop | VUE</title>
    <link rel="stylesheet" href="/assets/common.css">
    <link rel="stylesheet" href="/assets/article.css">
    <link rel="stylesheet" href="/assets/scribble.css">
    <link href="/assets/monokai_sublime.min.css" rel="stylesheet">  
    <script async src="/assets/highlight.min.js"></script>
    
</head>
<body>
    <article id="app">
        <header id="app_header">
          <h1>张集伟的个人博客</h1>
          <div class="content_box header_inner">
            <div class="logo">
              <div class="logoImg">
                <img src="/assets/icon.png" alt="">
              </div>
              <div class="logoText">
                jiw
              </div>
            </div>
            <nav class="navigator">
              <ul>
                
                <li class="" onclick="exec('linkTo', '/index.html')">
                    <a href="/index.html">
                        HOME
                    </a>
                </li>
                
                <li class="" onclick="exec('linkTo', '/category.html')">
                    <a href="/category.html">
                        CATEGORY
                    </a>
                </li>
                
                <li class="" onclick="exec('linkTo', '/tags.html')">
                    <a href="/tags.html">
                        标签
                    </a>
                </li>
                
                <li class="" onclick="exec('linkTo', '/link.html')">
                    <a href="/link.html">
                        链接
                    </a>
                </li>
                
                <li class="" onclick="exec('linkTo', '/about.html')">
                    <a href="/about.html">
                        关于我
                    </a>
                </li>
                
              </ul>
            </nav>
          </div>
        </header>
        <main id="main">
           <article class="content_box">
    <div class="article md_html_article" id="left_content">
        <h1>
            VUE
        </h1>
        <div class="update_time">
            <span>
                更新时间：2018-12-22
            </span>
        </div>
        <div id="write" class="md_essay">
            <h3 id="%E6%A6%82%E5%BF%B5">概念</h3>
<h4 id="%E9%A6%96%E5%85%88vue%E5%AE%9E%E4%BE%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">首先vue实例是什么？</h4>
<p>首先是一个js对象，负责管理视图数据，视图的渲染根据的是vue实例data，而视图上的动作可以与vue实例的方法绑定从而修改data，这就是一个双向的过程。</p>
<p>那么html模板的作用就明显了，vue实例需要绑定到html元素上才会起作用，所以html模板就是通过vue实例提供的数据与方法来动态渲染视图。</p>
<h4 id="vue%E7%BB%84%E4%BB%B6">vue组件</h4>
<p>将vue实例与html模板组合在一块，就可以组成一个既可以管理自身状态又可以与外界交互的vue组件。（当然对于一个vue组件来说vue实例并不是必要的）</p>
<h4 id="vue%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">vue实例生命周期</h4>
<p>vue实例从创建到销毁会经历一系列的阶段，在这些阶段会执行不同的方法，通过重写这些方法来在不同阶段执行一些特定的任务。</p>
<p><strong>beforeCreate</strong> -&gt; created -&gt; beforeMount -&gt; mounted -&gt; beforeUpdate -&gt; updated -&gt; <strong>destroyed</strong></p>
<h4 id="%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95">模板语法</h4>
<h5 id="%E6%8F%92%E5%80%BC">插值</h5>
<ol>
<li>
<p>文本</p>
<p>​</p>
<pre><code class="hljs language-vue">&lt;span&gt;Message: {{ msg }}&lt;/span&gt;
</code></pre>
</li>
<li>
<p>原始HTML</p>
<pre><code class="hljs language-vue">&lt;p&gt;Using mustaches: {{ rawHtml }}&lt;/p&gt;
&lt;p&gt;
  	Using v-html directive: 
  	&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
</code></pre>
</li>
<li>
<p>html特性</p>
<p>给html设置特性时，</p>
</li>
</ol>
<h4 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4">自定义指令</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//全局</span>
Vue.directive(<span class="hljs-string">'focus'</span>, {
  <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span>
  inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-comment">// 聚焦元素</span>
    el.focus()
  }
})
<span class="hljs-comment">//局部</span>
directives: {
  <span class="hljs-attr">focus</span>: {
    <span class="hljs-comment">// 指令的定义</span>
    inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{
      el.focus()
    }
  }
}
<span class="hljs-comment">//使用，focus时将自动获得焦点</span>
&lt;input v-focus&gt;
</code></pre>
<h5 id="%E6%8C%87%E4%BB%A4%E9%92%A9%E5%AD%90">指令钩子</h5>
<ul>
<li>bind: 只调用一次，指令第一次绑定到元素时调用</li>
<li>inserted：被绑定元素插入父节点时调用</li>
<li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。</li>
<li>componentUpdate：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li>unbind：只调用一次，指令与元素解绑时调。</li>
</ul>
<h5 id="%E6%8C%87%E4%BB%A4%E9%92%A9%E5%AD%90%E5%8F%82%E6%95%B0">指令钩子参数</h5>
<ul>
<li>el：指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li>binding：一个对象
<ul>
<li>name:指令名，不带 v-</li>
<li>value：指令值</li>
<li>oldValue：上一个之指令值</li>
<li>expression：字符串形式的指令表达式</li>
<li>arg：传给指令的参数，可选</li>
<li>modifiers：一个包含修饰符的对象。</li>
</ul>
</li>
<li>vnode：Vue编译生成的虚拟节点</li>
<li>oldVnode：上一个虚拟节点，仅在update和componentUpdated钩子中可用</li>
</ul>
<h4 id="%E8%BF%87%E6%BB%A4%E5%99%A8-vue.filter">过滤器 Vue.filter</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//全局</span>
Vue.filter(<span class="hljs-string">'my-filter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
  <span class="hljs-comment">// 返回处理后的值</span>
})
<span class="hljs-comment">//局部</span>
filters: {
  <span class="hljs-string">"my-filter"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-comment">// 返回处理后的值</span>
  }
}
<span class="hljs-comment">//使用</span>
<span class="hljs-comment">// 在双花括号中</span>
{{ data | myFilter }}
<span class="hljs-comment">// 在 `v-bind` 中</span>
&lt;div v-bind:id=<span class="hljs-string">"rawId | myFilter"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="hljs-comment">//接受参数。filterA接受的参数 message、arg1、arg2</span>
{{ message | filterA(<span class="hljs-string">'arg1'</span>, arg2) }}
</code></pre>
<h4 id="%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6-vue.component">全局组件 Vue.component</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 注册组件，传入一个扩展过的构造器</span>
Vue.component(<span class="hljs-string">'my-component'</span>, Vue.extend({ <span class="hljs-comment">/* ... */</span> }))

<span class="hljs-comment">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span>
Vue.component(<span class="hljs-string">'my-component'</span>, { <span class="hljs-comment">/* ... */</span> })

<span class="hljs-comment">// 获取注册的组件 (始终返回构造器)</span>
<span class="hljs-keyword">var</span> MyComponent = Vue.component(<span class="hljs-string">'my-component'</span>)
</code></pre>
<h4 id="%E6%8F%92%E4%BB%B6-vue.use(-plugin-)">插件 Vue.use( plugin )</h4>
<p>安装Vue插件，为vue添加全局功能，{Object | Function} plugin，如果是Object 必须提供install方法，如果是Function则直接当作install方法。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//定义插件</span>
MyPlugin.install = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) </span>{
  <span class="hljs-comment">// 1. 添加全局方法或属性</span>
  Vue.myGlobalMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 逻辑...</span>
  }

  <span class="hljs-comment">// 2. 添加全局资源</span>
  Vue.directive(<span class="hljs-string">'my-directive'</span>, {
    bind (el, binding, vnode, oldVnode) {
      <span class="hljs-comment">// 逻辑...</span>
    }
    ...
  })

  <span class="hljs-comment">// 3. 注入组件</span>
  Vue.mixin({
    <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">// 逻辑...</span>
    }
    ...
  })

  <span class="hljs-comment">// 4. 添加实例方法</span>
  Vue.prototype.$myMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">methodOptions</span>) </span>{
    <span class="hljs-comment">// 逻辑...</span>
  }
}
<span class="hljs-comment">//注册插件</span>
Vue.use(MyPlugin, { <span class="hljs-attr">someOption</span>: <span class="hljs-literal">true</span> })
<span class="hljs-comment">//使用....</span>
</code></pre>
<h4 id="%E5%85%A8%E5%B1%80%E6%B7%B7%E5%90%88-mixin">全局混合 mixin</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 为自定义的选项 'myOption' 注入一个处理器。</span>
Vue.mixin({
  <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> myOption = <span class="hljs-keyword">this</span>.$options.myOption
    <span class="hljs-keyword">if</span> (myOption) {
      <span class="hljs-built_in">console</span>.log(myOption)
    }
  }
})

<span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">myOption</span>: <span class="hljs-string">'hello!'</span>
})
<span class="hljs-comment">// =&gt; "hello!"</span>
</code></pre>
<p>自定义选项合并策略 Vue.config.optionMergeStrategies.myOption = function..</p>
<h4 id="%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0render">渲染函数render</h4>
<p>render函数的作用是来代替模板语法，当模板语法过于冗长，而且根据业务场景无法删减时，建议使用render。</p>
<p>render函数可以在定义组件时使用，也可以在渲染数据时使用（在渲染时对数据加工，修改外观、行为等，而不是单纯的数据渲染）</p>
<p>render函数第一个函数必须是 <strong>createElement</strong> 函数（别名 <strong>h</strong>），其他参数随意</p>
<p><strong>createElement</strong> 函数参数结构与dom节点树类似，第一个参数是一个字符串作为元素标签名，第二个参数是一个节点配置项（js对象），第三个参数是一个节点数组，节点可以是任意类型，所以可以嵌套<strong>createElement</strong> 来构造复杂的节点数。</p>
<p>配置项对象</p>
<pre><code class="hljs language-javascript">{
  <span class="hljs-comment">// 和`v-bind:class`一样的 API</span>
  <span class="hljs-string">'class'</span>: {
    <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-comment">// 和`v-bind:style`一样的 API</span>
  style: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'14px'</span>
  },
  <span class="hljs-comment">// 正常的 HTML 特性</span>
  attrs: {
    <span class="hljs-attr">id</span>: <span class="hljs-string">'foo'</span>
  },
  <span class="hljs-comment">// 组件 props</span>
  props: {
    <span class="hljs-attr">myProp</span>: <span class="hljs-string">'bar'</span>
  },
  <span class="hljs-comment">// DOM 属性</span>
  domProps: {
    <span class="hljs-attr">innerHTML</span>: <span class="hljs-string">'baz'</span>
  },
  <span class="hljs-comment">// 事件监听器基于 `on`</span>
  <span class="hljs-comment">// 所以不再支持如 `v-on:keyup.enter` 修饰器</span>
  <span class="hljs-comment">// 需要手动匹配 keyCode。</span>
  on: {
    <span class="hljs-attr">click</span>: <span class="hljs-keyword">this</span>.clickHandler
  },
  <span class="hljs-comment">// 仅对于组件，用于监听原生事件，而不是组件内部使用 `vm.$emit` 触发的事件。</span>
  nativeOn: {
    <span class="hljs-attr">click</span>: <span class="hljs-keyword">this</span>.nativeClickHandler
  },
  <span class="hljs-comment">// 自定义指令。注意，您无法对绑定中的 `oldValue` 赋值</span>
  <span class="hljs-comment">// Vue 会为您持续追踪</span>
  directives: [
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'my-custom-directive'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'2'</span>,
      <span class="hljs-attr">expression</span>: <span class="hljs-string">'1 + 1'</span>,
      <span class="hljs-attr">arg</span>: <span class="hljs-string">'foo'</span>,
      <span class="hljs-attr">modifiers</span>: {
        <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span>
      }
    }
  ],
  <span class="hljs-comment">// Scoped slots in the form of</span>
  <span class="hljs-comment">// { name: props =&gt; VNode | Array&lt;VNode&gt; }</span>
  scopedSlots: {
    <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> createElement(<span class="hljs-string">'span'</span>, props.text)
  },
  <span class="hljs-comment">// 如果组件是其他组件的子组件，需为插槽指定名称</span>
  slot: <span class="hljs-string">'name-of-slot'</span>,
  <span class="hljs-comment">// 其他特殊顶层属性</span>
  key: <span class="hljs-string">'myKey'</span>,
  <span class="hljs-attr">ref</span>: <span class="hljs-string">'myRef'</span>
}
</code></pre>
<h3 id="%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9">配置选项</h3>
<h4 id="%E6%95%B0%E6%8D%AE">数据</h4>
<h5 id="data">data</h5>
<ul>
<li><strong>类型</strong>：<code>Object | Function</code></li>
<li><strong>限制</strong>：组件的定义只接受 <code>function</code>。</li>
</ul>
<blockquote>
<p>Vue 实例的数据对象。Vue 将会递归将 data 的属性<strong>转换为 getter/setter</strong>，从而让 data 的属性能够响应数据变化。<strong>对象必须是纯粹的对象</strong> (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</p>
</blockquote>
<blockquote>
<p>以 <code>_</code> 或 <code>$</code> 开头的属性 <strong>不会</strong> 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。</p>
</blockquote>
<p>注意：不应使用箭头函数</p>
<h5 id="props">props</h5>
<p><strong>详情</strong> : <strong>props</strong> 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 对象语法，提供校验</span>
Vue.component(<span class="hljs-string">'props-demo-advanced'</span>, {
  <span class="hljs-attr">props</span>: {
    <span class="hljs-comment">// 检测类型</span>
    height: <span class="hljs-built_in">Number</span>,
    <span class="hljs-comment">// 检测类型 + 其他验证</span>
    age: {
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">0</span>
      }
    }
  }
})
</code></pre>
<h5 id="propsdata">propsData</h5>
<p>用于通过 new 创建实例时传递 props</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Comp = Vue.extend({
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'msg'</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;{{ msg }}&lt;/div&gt;'</span>
})

<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Comp({
  <span class="hljs-attr">propsData</span>: {
    <span class="hljs-attr">msg</span>: <span class="hljs-string">'hello'</span>
  }
})
</code></pre>
<h5 id="computed">computed</h5>
<p>计算属性，属性值必须是个函数，或者是一个具有get、set方法的对象，计算属性的结果会被缓存，是有实例内的相应式数据会触发它的重新计算，其他的变化都不会？？</p>
<h5 id="methods">methods</h5>
<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。</p>
<h5 id="watch">watch</h5>
<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>
  },
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'new: %s, old: %s'</span>, val, oldVal)
    },
    <span class="hljs-comment">// 方法名</span>
    b: <span class="hljs-string">'someMethod'</span>,
    <span class="hljs-comment">// 深度 watcher</span>
    c: {
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>{ <span class="hljs-comment">/* ... */</span> },
      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-comment">// 该回调将会在侦听开始之后被立即调用</span>
    d: {
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>{ <span class="hljs-comment">/* ... */</span> },
      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>
    }
  }
})
vm.a = <span class="hljs-number">2</span> <span class="hljs-comment">// =&gt; new: 2, old: 1</span>
</code></pre>
<h4 id="dom">DOM</h4>
<p>vue实例最终是要挂载到DOM节点上才会起作用，实例如何挂载到DOM节点？可以通过el、template、tender、renderError等属性来配置。</p>
<h5 id="el">el</h5>
<p>在由new创建实例时使用，可以是css选择器，或者HTMLElement实例</p>
<h5 id="template">template</h5>
<p>一个字符串模板作为vue实例的标识使用。</p>
<h5 id="render">render</h5>
<p>直接使用render函数传入的createElement来构造节点树</p>
<h5 id="rendererroe">renderErroe</h5>
<p>....</p>
<h4 id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">生命周期钩子</h4>
<h4 id="%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">实例属性</h4>
<ul>
<li>
<p><strong>vm.$slots</strong> : 用来访问被插槽分发的内容。(slot=&quot;foo&quot; 中的内容将会在 vm.$slots.foo 中被找到),default 属性包括了所有没有被包含在具名插槽中的节点。</p>
</li>
<li>
<p><strong>vm.$refs</strong> : 持有已注册过ref的所有子组件</p>
<pre><code class="hljs language-javascript">
</code></pre>
<p>​</p>
</li>
</ul>

        </div>
        <div class="md_essay_tags">
            
        </div>
    </div>
</article>
        </main>
        <footer id="footer"></footer>
      </article>
      <div class="shortcut-tools">
          <div onclick="exec('scrollToTop')" class="goto-top-btn">Top</div>
          <div onclick="exec('scrollToBottom')" class="goto-bottom-btn">Bottom</div>
          <div onclick="exec('goback')" class="goback-btn">goback</div>
      </div>
      <script src="/assets/common.js"></script>
</body>
</html>